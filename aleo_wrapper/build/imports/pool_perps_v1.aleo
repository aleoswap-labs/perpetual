import oracle_perps_v1.aleo;
program pool_perps_v1.aleo;

struct TokenInfo:
    name as field;
    symbol as field;
    decimals as u8;
    total_supply as u128;
    admin as address;

struct TokenId:
    base as address;
    creator as address;
    salt as u128;

struct AccountKey:
    token_id as field;
    user as address;

struct ApprovalKey:
    token_id as field;
    approver as address;
    spender as address;

struct AumConfig:
    addition as u128;
    deduction as u128;

struct FundingRateConfig:
    stable_funding_rate_factor as u128;
    funding_rate_factor as u128;

struct PositionKey:
    user as address;
    collateral_token_id as field;
    index_token_id as field;
    is_long as boolean;

struct Position:
    size as u128;
    collateral as u128;
    average_price as u128;
    entry_funding_rate as u128;
    reserve_amount as u128;
    realised_pnl as i128;
    last_increased_block as u32;


mapping tokens:
	key as field.public;
	value as TokenInfo.public;


mapping account:
	key as field.public;
	value as u128.public;


mapping approvals:
	key as field.public;
	value as u128.public;


mapping is_gov:
	key as address.public;
	value as boolean.public;


mapping whitelist_token_ids:
	key as boolean.public;
	value as [field; 5u32].public;


mapping aum_config:
	key as boolean.public;
	value as AumConfig.public;


mapping funding_rate_config:
	key as boolean.public;
	value as FundingRateConfig.public;


mapping stable_tokens:
	key as field.public;
	value as boolean.public;


mapping token_weights:
	key as field.public;
	value as u128.public;


mapping total_token_weights:
	key as boolean.public;
	value as u128.public;


mapping max_usda_amounts:
	key as field.public;
	value as u128.public;


mapping min_profit_basis_points:
	key as field.public;
	value as u32.public;


mapping min_profit_block:
	key as boolean.public;
	value as u32.public;


mapping in_private_liquidation_mode:
	key as boolean.public;
	value as boolean.public;


mapping is_liquidator:
	key as address.public;
	value as boolean.public;


mapping is_swap_enabled:
	key as boolean.public;
	value as boolean.public;


mapping in_manager_mode:
	key as boolean.public;
	value as boolean.public;


mapping is_manager:
	key as address.public;
	value as boolean.public;


mapping pool_amounts:
	key as field.public;
	value as u128.public;


mapping reserve_amounts:
	key as field.public;
	value as u128.public;


mapping usda_amounts:
	key as field.public;
	value as u128.public;


mapping cumulative_funding_rates:
	key as field.public;
	value as u128.public;


mapping fee_reserves:
	key as field.public;
	value as u128.public;


mapping positions:
	key as field.public;
	value as Position.public;


mapping guaranteed_usd:
	key as field.public;
	value as u128.public;


mapping global_short_sizes:
	key as field.public;
	value as u128.public;


mapping global_short_average_prices:
	key as field.public;
	value as u128.public;


mapping max_global_short_sizes:
	key as field.public;
	value as u128.public;


mapping last_funding_blocks:
	key as field.public;
	value as u32.public;


mapping last_added_at:
	key as address.public;
	value as u32.public;





function init:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as u128.public;
    assert.eq self.caller aleo1cnm2w8qlrhahlsmalph7t0jh3adny5pj4m38jgpcdzt2reqthurqaen3dp;
    cast aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y aleo1cnm2w8qlrhahlsmalph7t0jh3adny5pj4m38jgpcdzt2reqthurqaen3dp r5 into r6 as TokenId;
    hash.bhp256 r6 into r7 as field;
    cast r7 r4 into r8 as AccountKey;
    hash.bhp256 r8 into r9 as field;
    async init r7 r0 r1 r2 r3 r9 into r10;
    output r10 as pool_perps_v1.aleo/init.future;

finalize init:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u8.public;
    input r4 as u128.public;
    input r5 as field.public;
    contains tokens[r0] into r6;
    not r6 into r7;
    assert.eq r7 true;
    cast r1 r2 r3 r4 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r8 as TokenInfo;
    set r8 into tokens[r0];
    set r4 into account[r5];


function create_token:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as u128.public;
    gt r0 0field into r6;
    assert.eq r6 true;
    async create_token r0 r1 r2 r3 r4 self.caller r5 into r7;
    output r7 as pool_perps_v1.aleo/create_token.future;

finalize create_token:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as address.public;
    input r6 as u128.public;
    assert.eq r5 r4;
    cast aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y r5 r6 into r7 as TokenId;
    hash.bhp256 r7 into r8 as field;
    contains tokens[r8] into r9;
    not r9 into r10;
    assert.eq r10 true;
    cast r0 r1 r2 r3 r4 into r11 as TokenInfo;
    set r11 into tokens[r8];
    cast r8 r5 into r12 as AccountKey;
    hash.bhp256 r12 into r13 as field;
    set r3 into account[r13];


function mint:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async mint self.caller r0 r1 r2 into r3;
    output r3 as pool_perps_v1.aleo/mint.future;

finalize mint:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as u128.public;
    get tokens[r1] into r4;
    assert.eq r0 r4.admin;
    pow 10u128 6u8 into r5;
    mul r3 r5 into r6;
    pow 10u128 r4.decimals into r7;
    div r6 r7 into r8;
    add r4.total_supply r8 into r9;
    cast r4.name r4.symbol r4.decimals r9 r4.admin into r10 as TokenInfo;
    set r10 into tokens[r1];
    cast r1 r2 into r11 as AccountKey;
    hash.bhp256 r11 into r12 as field;
    get.or_use account[r12] 0u128 into r13;
    add r13 r8 into r14;
    set r14 into account[r12];




function burn_from:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 r1 self.caller into r3 as ApprovalKey;
    hash.bhp256 r3 into r4 as field;
    async burn_from self.caller r0 r4 r1 r2 into r5;
    output r5 as pool_perps_v1.aleo/burn_from.future;

finalize burn_from:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as address.public;
    input r4 as u128.public;
    get tokens[r1] into r5;
    assert.eq r0 r5.admin;
    pow 10u128 6u8 into r6;
    mul r4 r6 into r7;
    pow 10u128 r5.decimals into r8;
    div r7 r8 into r9;
    get approvals[r2] into r10;
    sub r10 r9 into r11;
    set r11 into approvals[r2];
    sub r5.total_supply r9 into r12;
    cast r5.name r5.symbol r5.decimals r12 r5.admin into r13 as TokenInfo;
    set r13 into tokens[r1];
    cast r1 r3 into r14 as AccountKey;
    hash.bhp256 r14 into r15 as field;
    get account[r15] into r16;
    sub r16 r9 into r17;
    set r17 into account[r15];


function transfer_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async transfer_public r0 self.caller r1 r2 into r3;
    output r3 as pool_perps_v1.aleo/transfer_public.future;

finalize transfer_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    contains tokens[r0] into r4;
    assert.eq r4 true;
    cast r0 r1 into r5 as AccountKey;
    hash.bhp256 r5 into r6 as field;
    get account[r6] into r7;
    sub r7 r3 into r8;
    set r8 into account[r6];
    cast r0 r2 into r9 as AccountKey;
    hash.bhp256 r9 into r10 as field;
    get.or_use account[r10] 0u128 into r11;
    add r11 r3 into r12;
    set r12 into account[r10];


function approve_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 self.caller r1 into r3 as ApprovalKey;
    hash.bhp256 r3 into r4 as field;
    async approve_public r0 r4 r2 into r5;
    output r5 as pool_perps_v1.aleo/approve_public.future;

finalize approve_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true;
    get.or_use approvals[r1] 0u128 into r4;
    sub 340282366920938463463374607431768211455u128 r4 into r5;
    lt r2 r5 into r6;
    add.w r4 r2 into r7;
    ternary r6 r7 340282366920938463463374607431768211455u128 into r8;
    set r8 into approvals[r1];


function unapprove_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 self.caller r1 into r3 as ApprovalKey;
    hash.bhp256 r3 into r4 as field;
    async unapprove_public r0 r4 r2 into r5;
    output r5 as pool_perps_v1.aleo/unapprove_public.future;

finalize unapprove_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true;
    get approvals[r1] into r4;
    gt r4 r2 into r5;
    sub.w r4 r2 into r6;
    ternary r5 r6 0u128 into r7;
    set r7 into approvals[r1];


function transfer_from:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    cast r0 r1 self.caller into r4 as ApprovalKey;
    hash.bhp256 r4 into r5 as field;
    async transfer_from r0 r5 r1 r2 r3 into r6;
    output r6 as pool_perps_v1.aleo/transfer_from.future;

finalize transfer_from:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as address.public;
    input r4 as u128.public;
    contains tokens[r0] into r5;
    assert.eq r5 true;
    get approvals[r1] into r6;
    sub r6 r4 into r7;
    set r7 into approvals[r1];
    cast r0 r2 into r8 as AccountKey;
    hash.bhp256 r8 into r9 as field;
    get account[r9] into r10;
    sub r10 r4 into r11;
    set r11 into account[r9];
    cast r0 r3 into r12 as AccountKey;
    hash.bhp256 r12 into r13 as field;
    get.or_use account[r13] 0u128 into r14;
    add r14 r4 into r15;
    set r15 into account[r13];








function add_liquidity:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as u128.public;
    input r3 as u128.public;
    gt r1 0u128 into r4;
    assert.eq r4 true;
    cast r0 self.caller into r5 as AccountKey;
    hash.bhp256 r5 into r6 as field;
    cast r0 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r7 as AccountKey;
    hash.bhp256 r7 into r8 as field;
    async add_liquidity self.caller r0 r1 r2 r3 r6 r8 into r9;
    output r9 as pool_perps_v1.aleo/add_liquidity.future;

finalize add_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as field.public;
    input r6 as field.public;
    contains tokens[r1] into r7;
    assert.eq r7 true;
    contains whitelist_token_ids[true] into r8;
    assert.eq r8 true;
    get whitelist_token_ids[true] into r9;
    is.eq r9[0u32] r1 into r10;
    is.eq r9[1u32] r1 into r11;
    or r10 r11 into r12;
    is.eq r9[2u32] r1 into r13;
    or r12 r13 into r14;
    is.eq r9[3u32] r1 into r15;
    or r14 r15 into r16;
    is.eq r9[4u32] r1 into r17;
    or r16 r17 into r18;
    assert.eq r18 true;
    get account[r5] into r19;
    sub r19 r2 into r20;
    set r20 into account[r5];
    get.or_use account[r6] 0u128 into r21;
    add r21 r2 into r22;
    set r22 into account[r6];
    contains aum_config[true] into r23;
    assert.eq r23 true;
    get aum_config[true] into r24;
    contains whitelist_token_ids[true] into r25;
    assert.eq r25 true;
    get whitelist_token_ids[true] into r26;
    get oracle_perps_v1.aleo/max_price[r26[0u32]] into r27;
    get.or_use pool_amounts[r26[0u32]] 0u128 into r28;
    get stable_tokens[r26[0u32]] into r29;
    mul r28 r27 into r30;
    pow 10u128 6u8 into r31;
    div r30 r31 into r32;
    add r24.addition r32 into r33;
    ternary r29 r33 r24.addition into r34;
    not r29 into r35;
    get.or_use global_short_sizes[r26[0u32]] 0u128 into r36;
    ternary r35 r36 0u128 into r37;
    not r29 into r38;
    gt r37 0u128 into r39;
    and r38 r39 into r40;
    get.or_use global_short_average_prices[r26[0u32]] 0u128 into r41;
    ternary r40 r41 0u128 into r42;
    gt r42 r27 into r43;
    sub.w r42 r27 into r44;
    sub.w r27 r42 into r45;
    ternary r43 r44 r45 into r46;
    is.eq r42 0u128 into r47;
    ternary r47 1u128 r42 into r48;
    is.neq r42 0u128 into r49;
    mul r37 r46 into r50;
    div.w r50 r48 into r51;
    ternary r49 r51 0u128 into r52;
    gt r42 r27 into r53;
    not r53 into r54;
    add r34 r52 into r55;
    ternary r54 r55 r34 into r56;
    add 0u128 r52 into r57;
    ternary r53 r57 0u128 into r58;
    not r29 into r59;
    get.or_use guaranteed_usd[r26[0u32]] 0u128 into r60;
    add r56 r60 into r61;
    ternary r59 r61 r56 into r62;
    get.or_use reserve_amounts[r26[0u32]] 0u128 into r63;
    not r29 into r64;
    sub.w r28 r63 into r65;
    mul r65 r27 into r66;
    pow 10u128 6u8 into r67;
    div r66 r67 into r68;
    add r62 r68 into r69;
    ternary r64 r69 r62 into r70;
    get oracle_perps_v1.aleo/max_price[r26[1u32]] into r71;
    get.or_use pool_amounts[r26[1u32]] 0u128 into r72;
    get stable_tokens[r26[1u32]] into r73;
    mul r72 r71 into r74;
    pow 10u128 6u8 into r75;
    div r74 r75 into r76;
    add r70 r76 into r77;
    ternary r73 r77 r70 into r78;
    not r73 into r79;
    get.or_use global_short_sizes[r26[1u32]] 0u128 into r80;
    ternary r79 r80 0u128 into r81;
    not r73 into r82;
    gt r81 0u128 into r83;
    and r82 r83 into r84;
    get.or_use global_short_average_prices[r26[1u32]] 0u128 into r85;
    ternary r84 r85 0u128 into r86;
    gt r86 r71 into r87;
    sub.w r86 r71 into r88;
    sub.w r71 r86 into r89;
    ternary r87 r88 r89 into r90;
    is.eq r86 0u128 into r91;
    ternary r91 1u128 r86 into r92;
    is.neq r86 0u128 into r93;
    mul r81 r90 into r94;
    div.w r94 r92 into r95;
    ternary r93 r95 0u128 into r96;
    gt r86 r71 into r97;
    not r97 into r98;
    add r78 r96 into r99;
    ternary r98 r99 r78 into r100;
    add r58 r96 into r101;
    ternary r97 r101 r58 into r102;
    not r73 into r103;
    get.or_use guaranteed_usd[r26[1u32]] 0u128 into r104;
    add r100 r104 into r105;
    ternary r103 r105 r100 into r106;
    get.or_use reserve_amounts[r26[1u32]] 0u128 into r107;
    not r73 into r108;
    sub.w r72 r107 into r109;
    mul r109 r71 into r110;
    pow 10u128 6u8 into r111;
    div r110 r111 into r112;
    add r106 r112 into r113;
    ternary r108 r113 r106 into r114;
    get oracle_perps_v1.aleo/max_price[r26[2u32]] into r115;
    get.or_use pool_amounts[r26[2u32]] 0u128 into r116;
    get stable_tokens[r26[2u32]] into r117;
    mul r116 r115 into r118;
    pow 10u128 6u8 into r119;
    div r118 r119 into r120;
    add r114 r120 into r121;
    ternary r117 r121 r114 into r122;
    not r117 into r123;
    get.or_use global_short_sizes[r26[2u32]] 0u128 into r124;
    ternary r123 r124 0u128 into r125;
    not r117 into r126;
    gt r125 0u128 into r127;
    and r126 r127 into r128;
    get.or_use global_short_average_prices[r26[2u32]] 0u128 into r129;
    ternary r128 r129 0u128 into r130;
    gt r130 r115 into r131;
    sub.w r130 r115 into r132;
    sub.w r115 r130 into r133;
    ternary r131 r132 r133 into r134;
    is.eq r130 0u128 into r135;
    ternary r135 1u128 r130 into r136;
    is.neq r130 0u128 into r137;
    mul r125 r134 into r138;
    div.w r138 r136 into r139;
    ternary r137 r139 0u128 into r140;
    gt r130 r115 into r141;
    not r141 into r142;
    add r122 r140 into r143;
    ternary r142 r143 r122 into r144;
    add r102 r140 into r145;
    ternary r141 r145 r102 into r146;
    not r117 into r147;
    get.or_use guaranteed_usd[r26[2u32]] 0u128 into r148;
    add r144 r148 into r149;
    ternary r147 r149 r144 into r150;
    get.or_use reserve_amounts[r26[2u32]] 0u128 into r151;
    not r117 into r152;
    sub.w r116 r151 into r153;
    mul r153 r115 into r154;
    pow 10u128 6u8 into r155;
    div r154 r155 into r156;
    add r150 r156 into r157;
    ternary r152 r157 r150 into r158;
    get oracle_perps_v1.aleo/max_price[r26[3u32]] into r159;
    get.or_use pool_amounts[r26[3u32]] 0u128 into r160;
    get stable_tokens[r26[3u32]] into r161;
    mul r160 r159 into r162;
    pow 10u128 6u8 into r163;
    div r162 r163 into r164;
    add r158 r164 into r165;
    ternary r161 r165 r158 into r166;
    not r161 into r167;
    get.or_use global_short_sizes[r26[3u32]] 0u128 into r168;
    ternary r167 r168 0u128 into r169;
    not r161 into r170;
    gt r169 0u128 into r171;
    and r170 r171 into r172;
    get.or_use global_short_average_prices[r26[3u32]] 0u128 into r173;
    ternary r172 r173 0u128 into r174;
    gt r174 r159 into r175;
    sub.w r174 r159 into r176;
    sub.w r159 r174 into r177;
    ternary r175 r176 r177 into r178;
    is.eq r174 0u128 into r179;
    ternary r179 1u128 r174 into r180;
    is.neq r174 0u128 into r181;
    mul r169 r178 into r182;
    div.w r182 r180 into r183;
    ternary r181 r183 0u128 into r184;
    gt r174 r159 into r185;
    not r185 into r186;
    add r166 r184 into r187;
    ternary r186 r187 r166 into r188;
    add r146 r184 into r189;
    ternary r185 r189 r146 into r190;
    not r161 into r191;
    get.or_use guaranteed_usd[r26[3u32]] 0u128 into r192;
    add r188 r192 into r193;
    ternary r191 r193 r188 into r194;
    get.or_use reserve_amounts[r26[3u32]] 0u128 into r195;
    not r161 into r196;
    sub.w r160 r195 into r197;
    mul r197 r159 into r198;
    pow 10u128 6u8 into r199;
    div r198 r199 into r200;
    add r194 r200 into r201;
    ternary r196 r201 r194 into r202;
    get oracle_perps_v1.aleo/max_price[r26[4u32]] into r203;
    get.or_use pool_amounts[r26[4u32]] 0u128 into r204;
    get stable_tokens[r26[4u32]] into r205;
    mul r204 r203 into r206;
    pow 10u128 6u8 into r207;
    div r206 r207 into r208;
    add r202 r208 into r209;
    ternary r205 r209 r202 into r210;
    not r205 into r211;
    get.or_use global_short_sizes[r26[4u32]] 0u128 into r212;
    ternary r211 r212 0u128 into r213;
    not r205 into r214;
    gt r213 0u128 into r215;
    and r214 r215 into r216;
    get.or_use global_short_average_prices[r26[4u32]] 0u128 into r217;
    ternary r216 r217 0u128 into r218;
    gt r218 r203 into r219;
    sub.w r218 r203 into r220;
    sub.w r203 r218 into r221;
    ternary r219 r220 r221 into r222;
    is.eq r218 0u128 into r223;
    ternary r223 1u128 r218 into r224;
    is.neq r218 0u128 into r225;
    mul r213 r222 into r226;
    div.w r226 r224 into r227;
    ternary r225 r227 0u128 into r228;
    gt r218 r203 into r229;
    not r229 into r230;
    add r210 r228 into r231;
    ternary r230 r231 r210 into r232;
    add r190 r228 into r233;
    ternary r229 r233 r190 into r234;
    not r205 into r235;
    get.or_use guaranteed_usd[r26[4u32]] 0u128 into r236;
    add r232 r236 into r237;
    ternary r235 r237 r232 into r238;
    get.or_use reserve_amounts[r26[4u32]] 0u128 into r239;
    not r205 into r240;
    sub.w r204 r239 into r241;
    mul r241 r203 into r242;
    pow 10u128 6u8 into r243;
    div r242 r243 into r244;
    add r238 r244 into r245;
    ternary r240 r245 r238 into r246;
    gt r234 r246 into r247;
    sub r246 r234 into r248;
    ternary r247 0u128 r248 into r249;
    gt r24.deduction r249 into r250;
    sub r249 r24.deduction into r251;
    ternary r250 0u128 r251 into r252;
    pow 10u128 6u8 into r253;
    mul r252 r253 into r254;
    pow 10u128 6u8 into r255;
    div r254 r255 into r256;
    get.or_use last_funding_blocks[r1] 0u32 into r257;
    div block.height 5760u32 into r258;
    mul r258 5760u32 into r259;
    is.eq r257 0u32 into r260;
    is.neq r257 0u32 into r261;
    add r257 5760u32 into r262;
    gt r262 block.height into r263;
    and r261 r263 into r264;
    ternary r264 r257 r259 into r265;
    ternary r260 r259 r265 into r266;
    get.or_use pool_amounts[r1] 0u128 into r267;
    sub block.height r257 into r268;
    div r268 5760u32 into r269;
    contains funding_rate_config[true] into r270;
    assert.eq r270 true;
    get funding_rate_config[true] into r271;
    get stable_tokens[r1] into r272;
    ternary r272 r271.stable_funding_rate_factor r271.funding_rate_factor into r273;
    is.eq r267 0u128 into r274;
    add r257 5760u32 into r275;
    gt r275 block.height into r276;
    or r274 r276 into r277;
    ternary r277 1u128 r267 into r278;
    is.eq r267 0u128 into r279;
    add r257 5760u32 into r280;
    gt r280 block.height into r281;
    or r279 r281 into r282;
    get.or_use reserve_amounts[r1] 0u128 into r283;
    mul r273 r283 into r284;
    cast r269 into r285 as u128;
    mul r284 r285 into r286;
    div.w r286 r278 into r287;
    ternary r282 0u128 r287 into r288;
    get.or_use cumulative_funding_rates[r1] 0u128 into r289;
    add r289 r288 into r290;
    set r290 into cumulative_funding_rates[r1];
    set r266 into last_funding_blocks[r1];
    get oracle_perps_v1.aleo/min_price[r1] into r291;
    mul r2 r291 into r292;
    pow 10u128 6u8 into r293;
    div r292 r293 into r294;
    gt r294 0u128 into r295;
    assert.eq r295 true;
    get.or_use usda_amounts[r1] 0u128 into r296;
    get tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field] into r297;
    contains total_token_weights[true] into r298;
    assert.eq r298 true;
    get total_token_weights[true] into r299;
    is.eq r299 0u128 into r300;
    ternary r300 1u128 r299 into r301;
    get.or_use token_weights[r1] 0u128 into r302;
    mul r302 r297.total_supply into r303;
    div r303 r301 into r304;
    add r296 r294 into r305;
    gt r294 r296 into r306;
    sub.w r296 r294 into r307;
    ternary r306 0u128 r307 into r308;
    ternary true r305 r308 into r309;
    gt r296 r304 into r310;
    sub.w r296 r304 into r311;
    sub.w r304 r296 into r312;
    ternary r310 r311 r312 into r313;
    gt r309 r304 into r314;
    sub.w r309 r304 into r315;
    sub.w r304 r309 into r316;
    ternary r314 r315 r316 into r317;
    is.neq r304 0u128 into r318;
    lt r317 r313 into r319;
    and r318 r319 into r320;
    ternary r320 r304 1u128 into r321;
    lt r317 r313 into r322;
    is.neq r304 0u128 into r323;
    and r322 r323 into r324;
    mul 50u128 r313 into r325;
    div r325 r321 into r326;
    ternary r324 r326 0u128 into r327;
    lt r317 r313 into r328;
    lte r327 30u128 into r329;
    and r328 r329 into r330;
    sub.w 30u128 r327 into r331;
    ternary r330 r331 0u128 into r332;
    gt r317 r313 into r333;
    add r313 r317 into r334;
    div r334 2u128 into r335;
    ternary r333 r335 0u128 into r336;
    gt r336 r304 into r337;
    ternary r337 r304 r336 into r338;
    is.eq r304 0u128 into r339;
    ternary r339 2u128 r304 into r340;
    not false into r341;
    is.eq r304 0u128 into r342;
    or r341 r342 into r343;
    lt r317 r313 into r344;
    mul 50u128 r338 into r345;
    div r345 r340 into r346;
    add 30u128 r346 into r347;
    ternary r344 r332 r347 into r348;
    ternary r343 30u128 r348 into r349;
    sub 10000u128 r349 into r350;
    mul r2 r350 into r351;
    div r351 10000u128 into r352;
    sub r2 r352 into r353;
    get.or_use fee_reserves[r1] 0u128 into r354;
    add r354 r353 into r355;
    set r355 into fee_reserves[r1];
    mul r352 r291 into r356;
    pow 10u128 6u8 into r357;
    div r356 r357 into r358;
    get.or_use usda_amounts[r1] 0u128 into r359;
    add r359 r358 into r360;
    set r360 into usda_amounts[r1];
    get.or_use max_usda_amounts[r1] 0u128 into r361;
    gt r361 0u128 into r362;
    get usda_amounts[r1] into r363;
    lte r363 r361 into r364;
    ternary r362 r364 true into r365;
    assert.eq r365 true;
    get.or_use pool_amounts[r1] 0u128 into r366;
    add r366 r352 into r367;
    set r367 into pool_amounts[r1];
    gte r358 r3 into r368;
    assert.eq r368 true;
    add r297.total_supply r358 into r369;
    cast r297.name r297.symbol r297.decimals r369 r297.admin into r370 as TokenInfo;
    set r370 into tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field];
    cast 5831693778411205416925069027464809696308596398099265250571387651489705378046field aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r371 as AccountKey;
    hash.bhp256 r371 into r372 as field;
    get.or_use account[r372] 0u128 into r373;
    add r373 r358 into r374;
    set r374 into account[r372];
    get tokens[6769995254802454894577392401849975163810476770055238272962759031196088045850field] into r375;
    is.eq r256 0u128 into r376;
    ternary r376 1u128 r256 into r377;
    is.eq r256 0u128 into r378;
    is.eq r375.total_supply 0u128 into r379;
    or r378 r379 into r380;
    mul r358 r375.total_supply into r381;
    div r381 r377 into r382;
    ternary r380 r358 r382 into r383;
    gte r383 r4 into r384;
    assert.eq r384 true;
    add r375.total_supply r383 into r385;
    cast r375.name r375.symbol r375.decimals r385 r375.admin into r386 as TokenInfo;
    set r386 into tokens[6769995254802454894577392401849975163810476770055238272962759031196088045850field];
    cast 6769995254802454894577392401849975163810476770055238272962759031196088045850field r0 into r387 as AccountKey;
    hash.bhp256 r387 into r388 as field;
    get.or_use account[r388] 0u128 into r389;
    add r389 r383 into r390;
    set r390 into account[r388];
    set block.height into last_added_at[r0];


function remove_liquidity:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as u128.public;
    input r3 as address.public;
    gt r1 0u128 into r4;
    assert.eq r4 true;
    async remove_liquidity self.caller r0 r1 r2 r3 into r5;
    output r5 as pool_perps_v1.aleo/remove_liquidity.future;

finalize remove_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    contains tokens[r1] into r5;
    assert.eq r5 true;
    contains whitelist_token_ids[true] into r6;
    assert.eq r6 true;
    get whitelist_token_ids[true] into r7;
    is.eq r7[0u32] r1 into r8;
    is.eq r7[1u32] r1 into r9;
    or r8 r9 into r10;
    is.eq r7[2u32] r1 into r11;
    or r10 r11 into r12;
    is.eq r7[3u32] r1 into r13;
    or r12 r13 into r14;
    is.eq r7[4u32] r1 into r15;
    or r14 r15 into r16;
    assert.eq r16 true;
    get last_added_at[r0] into r17;
    add r17 0u32 into r18;
    lte r18 block.height into r19;
    assert.eq r19 true;
    contains aum_config[true] into r20;
    assert.eq r20 true;
    get aum_config[true] into r21;
    contains whitelist_token_ids[true] into r22;
    assert.eq r22 true;
    get whitelist_token_ids[true] into r23;
    get oracle_perps_v1.aleo/min_price[r23[0u32]] into r24;
    get.or_use pool_amounts[r23[0u32]] 0u128 into r25;
    get stable_tokens[r23[0u32]] into r26;
    mul r25 r24 into r27;
    pow 10u128 6u8 into r28;
    div r27 r28 into r29;
    add r21.addition r29 into r30;
    ternary r26 r30 r21.addition into r31;
    not r26 into r32;
    get.or_use global_short_sizes[r23[0u32]] 0u128 into r33;
    ternary r32 r33 0u128 into r34;
    not r26 into r35;
    gt r34 0u128 into r36;
    and r35 r36 into r37;
    get.or_use global_short_average_prices[r23[0u32]] 0u128 into r38;
    ternary r37 r38 0u128 into r39;
    gt r39 r24 into r40;
    sub.w r39 r24 into r41;
    sub.w r24 r39 into r42;
    ternary r40 r41 r42 into r43;
    is.eq r39 0u128 into r44;
    ternary r44 1u128 r39 into r45;
    is.neq r39 0u128 into r46;
    mul r34 r43 into r47;
    div.w r47 r45 into r48;
    ternary r46 r48 0u128 into r49;
    gt r39 r24 into r50;
    not r50 into r51;
    add r31 r49 into r52;
    ternary r51 r52 r31 into r53;
    add 0u128 r49 into r54;
    ternary r50 r54 0u128 into r55;
    not r26 into r56;
    get.or_use guaranteed_usd[r23[0u32]] 0u128 into r57;
    add r53 r57 into r58;
    ternary r56 r58 r53 into r59;
    get.or_use reserve_amounts[r23[0u32]] 0u128 into r60;
    not r26 into r61;
    sub.w r25 r60 into r62;
    mul r62 r24 into r63;
    pow 10u128 6u8 into r64;
    div r63 r64 into r65;
    add r59 r65 into r66;
    ternary r61 r66 r59 into r67;
    get oracle_perps_v1.aleo/min_price[r23[1u32]] into r68;
    get.or_use pool_amounts[r23[1u32]] 0u128 into r69;
    get stable_tokens[r23[1u32]] into r70;
    mul r69 r68 into r71;
    pow 10u128 6u8 into r72;
    div r71 r72 into r73;
    add r67 r73 into r74;
    ternary r70 r74 r67 into r75;
    not r70 into r76;
    get.or_use global_short_sizes[r23[1u32]] 0u128 into r77;
    ternary r76 r77 0u128 into r78;
    not r70 into r79;
    gt r78 0u128 into r80;
    and r79 r80 into r81;
    get.or_use global_short_average_prices[r23[1u32]] 0u128 into r82;
    ternary r81 r82 0u128 into r83;
    gt r83 r68 into r84;
    sub.w r83 r68 into r85;
    sub.w r68 r83 into r86;
    ternary r84 r85 r86 into r87;
    is.eq r83 0u128 into r88;
    ternary r88 1u128 r83 into r89;
    is.neq r83 0u128 into r90;
    mul r78 r87 into r91;
    div.w r91 r89 into r92;
    ternary r90 r92 0u128 into r93;
    gt r83 r68 into r94;
    not r94 into r95;
    add r75 r93 into r96;
    ternary r95 r96 r75 into r97;
    add r55 r93 into r98;
    ternary r94 r98 r55 into r99;
    not r70 into r100;
    get.or_use guaranteed_usd[r23[1u32]] 0u128 into r101;
    add r97 r101 into r102;
    ternary r100 r102 r97 into r103;
    get.or_use reserve_amounts[r23[1u32]] 0u128 into r104;
    not r70 into r105;
    sub.w r69 r104 into r106;
    mul r106 r68 into r107;
    pow 10u128 6u8 into r108;
    div r107 r108 into r109;
    add r103 r109 into r110;
    ternary r105 r110 r103 into r111;
    get oracle_perps_v1.aleo/min_price[r23[2u32]] into r112;
    get.or_use pool_amounts[r23[2u32]] 0u128 into r113;
    get stable_tokens[r23[2u32]] into r114;
    mul r113 r112 into r115;
    pow 10u128 6u8 into r116;
    div r115 r116 into r117;
    add r111 r117 into r118;
    ternary r114 r118 r111 into r119;
    not r114 into r120;
    get.or_use global_short_sizes[r23[2u32]] 0u128 into r121;
    ternary r120 r121 0u128 into r122;
    not r114 into r123;
    gt r122 0u128 into r124;
    and r123 r124 into r125;
    get.or_use global_short_average_prices[r23[2u32]] 0u128 into r126;
    ternary r125 r126 0u128 into r127;
    gt r127 r112 into r128;
    sub.w r127 r112 into r129;
    sub.w r112 r127 into r130;
    ternary r128 r129 r130 into r131;
    is.eq r127 0u128 into r132;
    ternary r132 1u128 r127 into r133;
    is.neq r127 0u128 into r134;
    mul r122 r131 into r135;
    div.w r135 r133 into r136;
    ternary r134 r136 0u128 into r137;
    gt r127 r112 into r138;
    not r138 into r139;
    add r119 r137 into r140;
    ternary r139 r140 r119 into r141;
    add r99 r137 into r142;
    ternary r138 r142 r99 into r143;
    not r114 into r144;
    get.or_use guaranteed_usd[r23[2u32]] 0u128 into r145;
    add r141 r145 into r146;
    ternary r144 r146 r141 into r147;
    get.or_use reserve_amounts[r23[2u32]] 0u128 into r148;
    not r114 into r149;
    sub.w r113 r148 into r150;
    mul r150 r112 into r151;
    pow 10u128 6u8 into r152;
    div r151 r152 into r153;
    add r147 r153 into r154;
    ternary r149 r154 r147 into r155;
    get oracle_perps_v1.aleo/min_price[r23[3u32]] into r156;
    get.or_use pool_amounts[r23[3u32]] 0u128 into r157;
    get stable_tokens[r23[3u32]] into r158;
    mul r157 r156 into r159;
    pow 10u128 6u8 into r160;
    div r159 r160 into r161;
    add r155 r161 into r162;
    ternary r158 r162 r155 into r163;
    not r158 into r164;
    get.or_use global_short_sizes[r23[3u32]] 0u128 into r165;
    ternary r164 r165 0u128 into r166;
    not r158 into r167;
    gt r166 0u128 into r168;
    and r167 r168 into r169;
    get.or_use global_short_average_prices[r23[3u32]] 0u128 into r170;
    ternary r169 r170 0u128 into r171;
    gt r171 r156 into r172;
    sub.w r171 r156 into r173;
    sub.w r156 r171 into r174;
    ternary r172 r173 r174 into r175;
    is.eq r171 0u128 into r176;
    ternary r176 1u128 r171 into r177;
    is.neq r171 0u128 into r178;
    mul r166 r175 into r179;
    div.w r179 r177 into r180;
    ternary r178 r180 0u128 into r181;
    gt r171 r156 into r182;
    not r182 into r183;
    add r163 r181 into r184;
    ternary r183 r184 r163 into r185;
    add r143 r181 into r186;
    ternary r182 r186 r143 into r187;
    not r158 into r188;
    get.or_use guaranteed_usd[r23[3u32]] 0u128 into r189;
    add r185 r189 into r190;
    ternary r188 r190 r185 into r191;
    get.or_use reserve_amounts[r23[3u32]] 0u128 into r192;
    not r158 into r193;
    sub.w r157 r192 into r194;
    mul r194 r156 into r195;
    pow 10u128 6u8 into r196;
    div r195 r196 into r197;
    add r191 r197 into r198;
    ternary r193 r198 r191 into r199;
    get oracle_perps_v1.aleo/min_price[r23[4u32]] into r200;
    get.or_use pool_amounts[r23[4u32]] 0u128 into r201;
    get stable_tokens[r23[4u32]] into r202;
    mul r201 r200 into r203;
    pow 10u128 6u8 into r204;
    div r203 r204 into r205;
    add r199 r205 into r206;
    ternary r202 r206 r199 into r207;
    not r202 into r208;
    get.or_use global_short_sizes[r23[4u32]] 0u128 into r209;
    ternary r208 r209 0u128 into r210;
    not r202 into r211;
    gt r210 0u128 into r212;
    and r211 r212 into r213;
    get.or_use global_short_average_prices[r23[4u32]] 0u128 into r214;
    ternary r213 r214 0u128 into r215;
    gt r215 r200 into r216;
    sub.w r215 r200 into r217;
    sub.w r200 r215 into r218;
    ternary r216 r217 r218 into r219;
    is.eq r215 0u128 into r220;
    ternary r220 1u128 r215 into r221;
    is.neq r215 0u128 into r222;
    mul r210 r219 into r223;
    div.w r223 r221 into r224;
    ternary r222 r224 0u128 into r225;
    gt r215 r200 into r226;
    not r226 into r227;
    add r207 r225 into r228;
    ternary r227 r228 r207 into r229;
    add r187 r225 into r230;
    ternary r226 r230 r187 into r231;
    not r202 into r232;
    get.or_use guaranteed_usd[r23[4u32]] 0u128 into r233;
    add r229 r233 into r234;
    ternary r232 r234 r229 into r235;
    get.or_use reserve_amounts[r23[4u32]] 0u128 into r236;
    not r202 into r237;
    sub.w r201 r236 into r238;
    mul r238 r200 into r239;
    pow 10u128 6u8 into r240;
    div r239 r240 into r241;
    add r235 r241 into r242;
    ternary r237 r242 r235 into r243;
    gt r231 r243 into r244;
    sub r243 r231 into r245;
    ternary r244 0u128 r245 into r246;
    gt r21.deduction r246 into r247;
    sub r246 r21.deduction into r248;
    ternary r247 0u128 r248 into r249;
    pow 10u128 6u8 into r250;
    mul r249 r250 into r251;
    pow 10u128 6u8 into r252;
    div r251 r252 into r253;
    get tokens[6769995254802454894577392401849975163810476770055238272962759031196088045850field] into r254;
    mul r2 r253 into r255;
    div r255 r254.total_supply into r256;
    assert.eq r254.admin aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y;
    sub r254.total_supply r2 into r257;
    cast r254.name r254.symbol r254.decimals r257 r254.admin into r258 as TokenInfo;
    set r258 into tokens[6769995254802454894577392401849975163810476770055238272962759031196088045850field];
    cast 6769995254802454894577392401849975163810476770055238272962759031196088045850field r0 into r259 as AccountKey;
    hash.bhp256 r259 into r260 as field;
    get account[r260] into r261;
    gte r261 r2 into r262;
    assert.eq r262 true;
    get account[r260] into r263;
    sub r263 r2 into r264;
    set r264 into account[r260];
    get.or_use last_funding_blocks[r1] 0u32 into r265;
    div block.height 5760u32 into r266;
    mul r266 5760u32 into r267;
    is.eq r265 0u32 into r268;
    is.neq r265 0u32 into r269;
    add r265 5760u32 into r270;
    gt r270 block.height into r271;
    and r269 r271 into r272;
    ternary r272 r265 r267 into r273;
    ternary r268 r267 r273 into r274;
    get.or_use pool_amounts[r1] 0u128 into r275;
    sub block.height r265 into r276;
    div r276 5760u32 into r277;
    contains funding_rate_config[true] into r278;
    assert.eq r278 true;
    get funding_rate_config[true] into r279;
    get stable_tokens[r1] into r280;
    ternary r280 r279.stable_funding_rate_factor r279.funding_rate_factor into r281;
    is.eq r275 0u128 into r282;
    add r265 5760u32 into r283;
    gt r283 block.height into r284;
    or r282 r284 into r285;
    ternary r285 1u128 r275 into r286;
    is.eq r275 0u128 into r287;
    add r265 5760u32 into r288;
    gt r288 block.height into r289;
    or r287 r289 into r290;
    get.or_use reserve_amounts[r1] 0u128 into r291;
    mul r281 r291 into r292;
    cast r277 into r293 as u128;
    mul r292 r293 into r294;
    div.w r294 r286 into r295;
    ternary r290 0u128 r295 into r296;
    get.or_use cumulative_funding_rates[r1] 0u128 into r297;
    add r297 r296 into r298;
    set r298 into cumulative_funding_rates[r1];
    set r274 into last_funding_blocks[r1];
    get oracle_perps_v1.aleo/max_price[r1] into r299;
    pow 10u128 6u8 into r300;
    mul r256 r300 into r301;
    div r301 r299 into r302;
    gt r302 0u128 into r303;
    assert.eq r303 true;
    get.or_use usda_amounts[r1] 0u128 into r304;
    lte r256 r304 into r305;
    sub.w r304 r256 into r306;
    ternary r305 r306 0u128 into r307;
    set r307 into usda_amounts[r1];
    get pool_amounts[r1] into r308;
    gte r308 r302 into r309;
    assert.eq r309 true;
    get pool_amounts[r1] into r310;
    sub r310 r302 into r311;
    set r311 into pool_amounts[r1];
    get pool_amounts[r1] into r312;
    get.or_use reserve_amounts[r1] 0u128 into r313;
    gte r312 r313 into r314;
    assert.eq r314 true;
    cast 5831693778411205416925069027464809696308596398099265250571387651489705378046field aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r315 as AccountKey;
    hash.bhp256 r315 into r316 as field;
    get.or_use account[r316] 0u128 into r317;
    gt r317 r256 into r318;
    ternary r318 r256 r317 into r319;
    get tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field] into r320;
    assert.eq r320.admin aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y;
    sub r320.total_supply r319 into r321;
    cast r320.name r320.symbol r320.decimals r321 r320.admin into r322 as TokenInfo;
    set r322 into tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field];
    sub r317 r319 into r323;
    set r323 into account[r316];
    get.or_use usda_amounts[r1] 0u128 into r324;
    contains total_token_weights[true] into r325;
    assert.eq r325 true;
    get total_token_weights[true] into r326;
    is.eq r326 0u128 into r327;
    ternary r327 1u128 r326 into r328;
    get.or_use token_weights[r1] 0u128 into r329;
    mul r329 r320.total_supply into r330;
    div r330 r328 into r331;
    add r324 r256 into r332;
    gt r256 r324 into r333;
    sub.w r324 r256 into r334;
    ternary r333 0u128 r334 into r335;
    ternary false r332 r335 into r336;
    gt r324 r331 into r337;
    sub.w r324 r331 into r338;
    sub.w r331 r324 into r339;
    ternary r337 r338 r339 into r340;
    gt r336 r331 into r341;
    sub.w r336 r331 into r342;
    sub.w r331 r336 into r343;
    ternary r341 r342 r343 into r344;
    is.neq r331 0u128 into r345;
    lt r344 r340 into r346;
    and r345 r346 into r347;
    ternary r347 r331 1u128 into r348;
    lt r344 r340 into r349;
    is.neq r331 0u128 into r350;
    and r349 r350 into r351;
    mul 50u128 r340 into r352;
    div r352 r348 into r353;
    ternary r351 r353 0u128 into r354;
    lt r344 r340 into r355;
    lte r354 30u128 into r356;
    and r355 r356 into r357;
    sub.w 30u128 r354 into r358;
    ternary r357 r358 0u128 into r359;
    gt r344 r340 into r360;
    add r340 r344 into r361;
    div r361 2u128 into r362;
    ternary r360 r362 0u128 into r363;
    gt r363 r331 into r364;
    ternary r364 r331 r363 into r365;
    is.eq r331 0u128 into r366;
    ternary r366 2u128 r331 into r367;
    not false into r368;
    is.eq r331 0u128 into r369;
    or r368 r369 into r370;
    lt r344 r340 into r371;
    mul 50u128 r365 into r372;
    div r372 r367 into r373;
    add 30u128 r373 into r374;
    ternary r371 r359 r374 into r375;
    ternary r370 30u128 r375 into r376;
    sub 10000u128 r376 into r377;
    mul r302 r377 into r378;
    div r378 10000u128 into r379;
    sub r302 r379 into r380;
    get.or_use fee_reserves[r1] 0u128 into r381;
    add r381 r380 into r382;
    set r382 into fee_reserves[r1];
    gte r379 r3 into r383;
    assert.eq r383 true;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r384 as AccountKey;
    hash.bhp256 r384 into r385 as field;
    get account[r385] into r386;
    sub r386 r379 into r387;
    set r387 into account[r385];
    cast r1 r4 into r388 as AccountKey;
    hash.bhp256 r388 into r389 as field;
    get.or_use account[r389] 0u128 into r390;
    add r390 r379 into r391;
    set r391 into account[r389];


function direct_pool_deposit:
    input r0 as field.public;
    input r1 as u128.public;
    gt r1 0u128 into r2;
    assert.eq r2 true;
    cast r0 self.caller into r3 as AccountKey;
    hash.bhp256 r3 into r4 as field;
    cast r0 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r5 as AccountKey;
    hash.bhp256 r5 into r6 as field;
    async direct_pool_deposit r4 r6 r0 r1 into r7;
    output r7 as pool_perps_v1.aleo/direct_pool_deposit.future;

finalize direct_pool_deposit:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    contains whitelist_token_ids[true] into r4;
    assert.eq r4 true;
    get whitelist_token_ids[true] into r5;
    is.eq r5[0u32] r2 into r6;
    is.eq r5[1u32] r2 into r7;
    or r6 r7 into r8;
    is.eq r5[2u32] r2 into r9;
    or r8 r9 into r10;
    is.eq r5[3u32] r2 into r11;
    or r10 r11 into r12;
    is.eq r5[4u32] r2 into r13;
    or r12 r13 into r14;
    assert.eq r14 true;
    contains tokens[r2] into r15;
    assert.eq r15 true;
    get account[r0] into r16;
    sub r16 r3 into r17;
    set r17 into account[r0];
    get.or_use account[r1] 0u128 into r18;
    add r18 r3 into r19;
    set r19 into account[r1];
    get.or_use pool_amounts[r2] 0u128 into r20;
    add r20 r3 into r21;
    set r21 into pool_amounts[r2];
    get pool_amounts[r2] into r22;
    get account[r1] into r23;
    lte r22 r23 into r24;
    assert.eq r24 true;
















function increase_position:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as boolean.public;
    input r5 as u128.public;
    gt r1 0u128 into r6;
    assert.eq r6 true;
    async increase_position self.caller r0 r1 r2 r3 r4 r5 into r7;
    output r7 as pool_perps_v1.aleo/increase_position.future;

finalize increase_position:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as field.public;
    input r4 as u128.public;
    input r5 as boolean.public;
    input r6 as u128.public;
    contains whitelist_token_ids[true] into r7;
    assert.eq r7 true;
    get whitelist_token_ids[true] into r8;
    is.eq r8[0u32] r1 into r9;
    is.eq r8[1u32] r1 into r10;
    or r9 r10 into r11;
    is.eq r8[2u32] r1 into r12;
    or r11 r12 into r13;
    is.eq r8[3u32] r1 into r14;
    or r13 r14 into r15;
    is.eq r8[4u32] r1 into r16;
    or r15 r16 into r17;
    assert.eq r17 true;
    get whitelist_token_ids[true] into r18;
    is.eq r18[0u32] r3 into r19;
    is.eq r18[1u32] r3 into r20;
    or r19 r20 into r21;
    is.eq r18[2u32] r3 into r22;
    or r21 r22 into r23;
    is.eq r18[3u32] r3 into r24;
    or r23 r24 into r25;
    is.eq r18[4u32] r3 into r26;
    or r25 r26 into r27;
    assert.eq r27 true;
    contains tokens[r1] into r28;
    assert.eq r28 true;
    contains tokens[r3] into r29;
    assert.eq r29 true;
    is.eq r1 r3 into r30;
    get stable_tokens[r1] into r31;
    not r31 into r32;
    and r30 r32 into r33;
    get stable_tokens[r1] into r34;
    get stable_tokens[r3] into r35;
    not r35 into r36;
    and r34 r36 into r37;
    ternary r5 r33 r37 into r38;
    assert.eq r38 true;
    get oracle_perps_v1.aleo/max_price[r3] into r39;
    get oracle_perps_v1.aleo/min_price[r3] into r40;
    lte r39 r6 into r41;
    gte r40 r6 into r42;
    ternary r5 r41 r42 into r43;
    assert.eq r43 true;
    cast r1 r0 into r44 as AccountKey;
    hash.bhp256 r44 into r45 as field;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r46 as AccountKey;
    hash.bhp256 r46 into r47 as field;
    get account[r45] into r48;
    gte r48 r2 into r49;
    assert.eq r49 true;
    get account[r45] into r50;
    sub r50 r2 into r51;
    set r51 into account[r45];
    get.or_use account[r47] 0u128 into r52;
    add r52 r2 into r53;
    set r53 into account[r47];
    get.or_use last_funding_blocks[r1] 0u32 into r54;
    div block.height 5760u32 into r55;
    mul r55 5760u32 into r56;
    is.eq r54 0u32 into r57;
    is.neq r54 0u32 into r58;
    add r54 5760u32 into r59;
    gt r59 block.height into r60;
    and r58 r60 into r61;
    ternary r61 r54 r56 into r62;
    ternary r57 r56 r62 into r63;
    get.or_use pool_amounts[r1] 0u128 into r64;
    sub block.height r54 into r65;
    div r65 5760u32 into r66;
    contains funding_rate_config[true] into r67;
    assert.eq r67 true;
    get funding_rate_config[true] into r68;
    get stable_tokens[r1] into r69;
    ternary r69 r68.stable_funding_rate_factor r68.funding_rate_factor into r70;
    is.eq r64 0u128 into r71;
    add r54 5760u32 into r72;
    gt r72 block.height into r73;
    or r71 r73 into r74;
    ternary r74 1u128 r64 into r75;
    is.eq r64 0u128 into r76;
    add r54 5760u32 into r77;
    gt r77 block.height into r78;
    or r76 r78 into r79;
    get.or_use reserve_amounts[r1] 0u128 into r80;
    mul r70 r80 into r81;
    cast r66 into r82 as u128;
    mul r81 r82 into r83;
    div.w r83 r75 into r84;
    ternary r79 0u128 r84 into r85;
    get.or_use cumulative_funding_rates[r1] 0u128 into r86;
    add r86 r85 into r87;
    set r87 into cumulative_funding_rates[r1];
    set r63 into last_funding_blocks[r1];
    cast r0 r1 r3 r5 into r88 as PositionKey;
    hash.bhp256 r88 into r89 as field;
    cast 0u128 0u128 0u128 0u128 0u128 0i128 0u32 into r90 as Position;
    get.or_use positions[r89] r90 into r91;
    ternary r5 r39 r40 into r92;
    ternary r5 r40 r39 into r93;
    contains min_profit_block[true] into r94;
    assert.eq r94 true;
    get min_profit_block[true] into r95;
    add r91.last_increased_block r95 into r96;
    gt block.height r96 into r97;
    get.or_use min_profit_basis_points[r3] 0u32 into r98;
    ternary r97 0u32 r98 into r99;
    gt r91.average_price r93 into r100;
    sub.w r91.average_price r93 into r101;
    sub.w r93 r91.average_price into r102;
    ternary r100 r101 r102 into r103;
    is.eq r91.average_price 0u128 into r104;
    ternary r104 1u128 r91.average_price into r105;
    is.eq r91.average_price 0u128 into r106;
    mul r91.size r103 into r107;
    div.w r107 r105 into r108;
    ternary r106 0u128 r108 into r109;
    gt r93 r91.average_price into r110;
    gt r91.average_price r93 into r111;
    ternary r5 r110 r111 into r112;
    mul r109 10000u128 into r113;
    cast r99 into r114 as u128;
    mul r91.size r114 into r115;
    lte r113 r115 into r116;
    and r112 r116 into r117;
    ternary r117 0u128 r109 into r118;
    add r91.size r4 into r119;
    add r119 r118 into r120;
    sub.w r119 r118 into r121;
    ternary r112 r120 r121 into r122;
    sub.w r119 r118 into r123;
    add r119 r118 into r124;
    ternary r112 r123 r124 into r125;
    ternary r5 r122 r125 into r126;
    mul r92 r119 into r127;
    div r127 r126 into r128;
    is.eq r91.size 0u128 into r129;
    gt r91.size 0u128 into r130;
    gt r4 0u128 into r131;
    and r130 r131 into r132;
    ternary r132 r128 r91.average_price into r133;
    ternary r129 r92 r133 into r134;
    get.or_use cumulative_funding_rates[r1] 0u128 into r135;
    is.eq r4 0u128 into r136;
    sub 10000u128 10u128 into r137;
    mul r4 r137 into r138;
    div r138 10000u128 into r139;
    sub r4 r139 into r140;
    ternary r136 0u128 r140 into r141;
    sub r135 r91.entry_funding_rate into r142;
    is.eq r91.size 0u128 into r143;
    is.eq r142 0u128 into r144;
    or r143 r144 into r145;
    mul r91.size r142 into r146;
    div r146 1000000u128 into r147;
    ternary r145 0u128 r147 into r148;
    add r141 r148 into r149;
    get oracle_perps_v1.aleo/max_price[r1] into r150;
    pow 10u128 6u8 into r151;
    mul r149 r151 into r152;
    div r152 r150 into r153;
    get.or_use fee_reserves[r1] 0u128 into r154;
    add r154 r153 into r155;
    set r155 into fee_reserves[r1];
    get oracle_perps_v1.aleo/min_price[r1] into r156;
    mul r2 r156 into r157;
    pow 10u128 6u8 into r158;
    div r157 r158 into r159;
    add r91.collateral r159 into r160;
    sub r160 r149 into r161;
    gte r161 0u128 into r162;
    assert.eq r162 true;
    add r91.size r4 into r163;
    gte r163 r161 into r164;
    assert.eq r164 true;
    pow 10u128 6u8 into r165;
    mul r4 r165 into r166;
    div r166 r156 into r167;
    add r91.reserve_amount r167 into r168;
    cast r163 r161 r134 r135 r168 r91.realised_pnl block.height into r169 as Position;
    set r169 into positions[r89];
    get positions[r89] into r170;
    gt r170.average_price r93 into r171;
    sub.w r170.average_price r93 into r172;
    sub.w r93 r170.average_price into r173;
    ternary r171 r172 r173 into r174;
    is.eq r170.average_price 0u128 into r175;
    ternary r175 1u128 r170.average_price into r176;
    is.eq r170.average_price 0u128 into r177;
    mul r170.size r174 into r178;
    div.w r178 r176 into r179;
    ternary r177 0u128 r179 into r180;
    gt r93 r170.average_price into r181;
    gt r170.average_price r93 into r182;
    ternary r5 r181 r182 into r183;
    mul r180 10000u128 into r184;
    cast r99 into r185 as u128;
    mul r170.size r185 into r186;
    lte r184 r186 into r187;
    and r183 r187 into r188;
    ternary r188 0u128 r180 into r189;
    is.eq r170.size 0u128 into r190;
    sub 10000u128 10u128 into r191;
    mul r170.size r191 into r192;
    div r192 10000u128 into r193;
    sub r170.size r193 into r194;
    ternary r190 0u128 r194 into r195;
    sub r135 r170.entry_funding_rate into r196;
    is.eq r170.size 0u128 into r197;
    is.eq r196 0u128 into r198;
    or r197 r198 into r199;
    mul r170.size r196 into r200;
    div r200 1000000u128 into r201;
    ternary r199 0u128 r201 into r202;
    add r195 r202 into r203;
    not r183 into r204;
    gte r161 r189 into r205;
    and r204 r205 into r206;
    sub.w r161 r189 into r207;
    ternary r206 r207 0u128 into r208;
    ternary r183 r161 r208 into r209;
    is.neq r209 0u128 into r210;
    lt r209 r203 into r211;
    and r210 r211 into r212;
    is.neq r209 0u128 into r213;
    gte r209 r203 into r214;
    and r213 r214 into r215;
    add r203 5000000u128 into r216;
    lt r209 r216 into r217;
    and r215 r217 into r218;
    is.neq r209 0u128 into r219;
    add r203 5000000u128 into r220;
    gte r209 r220 into r221;
    and r219 r221 into r222;
    mul r209 500000u128 into r223;
    mul r163 10000u128 into r224;
    lt r223 r224 into r225;
    and r222 r225 into r226;
    is.eq r209 0u128 into r227;
    or r227 r212 into r228;
    or r228 r218 into r229;
    ternary r226 2u8 0u8 into r230;
    ternary r229 1u8 r230 into r231;
    ternary r212 r209 r203 into r232;
    is.eq r231 0u8 into r233;
    assert.eq r233 true;
    get.or_use reserve_amounts[r1] 0u128 into r234;
    add r234 r167 into r235;
    set r235 into reserve_amounts[r1];
    get reserve_amounts[r1] into r236;
    get pool_amounts[r1] into r237;
    lte r236 r237 into r238;
    assert.eq r238 true;
    get.or_use guaranteed_usd[r1] 0u128 into r239;
    add r239 r4 into r240;
    add r240 r149 into r241;
    sub.w r241 r159 into r242;
    ternary r5 r242 r239 into r243;
    get.or_use pool_amounts[r1] 0u128 into r244;
    add r244 r2 into r245;
    sub.w r245 r153 into r246;
    get.or_use pool_amounts[r1] 0u128 into r247;
    ternary r5 r246 r247 into r248;
    set r243 into guaranteed_usd[r1];
    set r248 into pool_amounts[r1];
    get.or_use global_short_sizes[r3] 0u128 into r249;
    get.or_use global_short_average_prices[r3] 0u128 into r250;
    not r5 into r251;
    is.neq r249 0u128 into r252;
    and r251 r252 into r253;
    gt r250 r92 into r254;
    sub.w r250 r92 into r255;
    sub.w r92 r250 into r256;
    ternary r254 r255 r256 into r257;
    is.eq r250 0u128 into r258;
    ternary r258 1u128 r250 into r259;
    is.eq r250 0u128 into r260;
    mul r249 r257 into r261;
    div r261 r259 into r262;
    ternary r260 0u128 r262 into r263;
    gt r250 r92 into r264;
    add r249 r4 into r265;
    sub r265 r263 into r266;
    add r265 r263 into r267;
    ternary r264 r266 r267 into r268;
    mul r92 r265 into r269;
    div r269 r268 into r270;
    ternary r253 r270 0u128 into r271;
    not r5 into r272;
    is.eq r249 0u128 into r273;
    and r272 r273 into r274;
    not r5 into r275;
    is.neq r249 0u128 into r276;
    and r275 r276 into r277;
    ternary r277 r271 r250 into r278;
    ternary r274 r92 r278 into r279;
    set r279 into global_short_average_prices[r3];
    add r249 r4 into r280;
    ternary r5 r249 r280 into r281;
    set r281 into global_short_sizes[r3];
    get.or_use max_global_short_sizes[r3] 0u128 into r282;
    is.neq r282 0u128 into r283;
    lte r281 r282 into r284;
    ternary r283 r284 true into r285;
    assert.eq r285 true;


function decrease_position:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as boolean.public;
    input r5 as address.public;
    input r6 as u128.public;
    async decrease_position self.caller r0 r1 r2 r3 r4 r5 r6 into r7;
    output r7 as pool_perps_v1.aleo/decrease_position.future;

finalize decrease_position:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as boolean.public;
    input r6 as address.public;
    input r7 as u128.public;
    contains tokens[r1] into r8;
    assert.eq r8 true;
    contains tokens[r2] into r9;
    assert.eq r9 true;
    contains whitelist_token_ids[true] into r10;
    assert.eq r10 true;
    get whitelist_token_ids[true] into r11;
    is.eq r11[0u32] r1 into r12;
    is.eq r11[1u32] r1 into r13;
    or r12 r13 into r14;
    is.eq r11[2u32] r1 into r15;
    or r14 r15 into r16;
    is.eq r11[3u32] r1 into r17;
    or r16 r17 into r18;
    is.eq r11[4u32] r1 into r19;
    or r18 r19 into r20;
    assert.eq r20 true;
    get whitelist_token_ids[true] into r21;
    is.eq r21[0u32] r2 into r22;
    is.eq r21[1u32] r2 into r23;
    or r22 r23 into r24;
    is.eq r21[2u32] r2 into r25;
    or r24 r25 into r26;
    is.eq r21[3u32] r2 into r27;
    or r26 r27 into r28;
    is.eq r21[4u32] r2 into r29;
    or r28 r29 into r30;
    assert.eq r30 true;
    get oracle_perps_v1.aleo/max_price[r2] into r31;
    get oracle_perps_v1.aleo/min_price[r2] into r32;
    gte r32 r7 into r33;
    lte r31 r7 into r34;
    ternary r5 r33 r34 into r35;
    assert.eq r35 true;
    get.or_use last_funding_blocks[r1] 0u32 into r36;
    div block.height 5760u32 into r37;
    mul r37 5760u32 into r38;
    is.eq r36 0u32 into r39;
    is.neq r36 0u32 into r40;
    add r36 5760u32 into r41;
    gt r41 block.height into r42;
    and r40 r42 into r43;
    ternary r43 r36 r38 into r44;
    ternary r39 r38 r44 into r45;
    get.or_use pool_amounts[r1] 0u128 into r46;
    sub block.height r36 into r47;
    div r47 5760u32 into r48;
    contains funding_rate_config[true] into r49;
    assert.eq r49 true;
    get funding_rate_config[true] into r50;
    get stable_tokens[r1] into r51;
    ternary r51 r50.stable_funding_rate_factor r50.funding_rate_factor into r52;
    is.eq r46 0u128 into r53;
    add r36 5760u32 into r54;
    gt r54 block.height into r55;
    or r53 r55 into r56;
    ternary r56 1u128 r46 into r57;
    is.eq r46 0u128 into r58;
    add r36 5760u32 into r59;
    gt r59 block.height into r60;
    or r58 r60 into r61;
    get.or_use reserve_amounts[r1] 0u128 into r62;
    mul r52 r62 into r63;
    cast r48 into r64 as u128;
    mul r63 r64 into r65;
    div.w r65 r57 into r66;
    ternary r61 0u128 r66 into r67;
    get.or_use cumulative_funding_rates[r1] 0u128 into r68;
    add r68 r67 into r69;
    set r69 into cumulative_funding_rates[r1];
    set r45 into last_funding_blocks[r1];
    cast r0 r1 r2 r5 into r70 as PositionKey;
    hash.bhp256 r70 into r71 as field;
    get positions[r71] into r72;
    gt r72.size 0u128 into r73;
    assert.eq r73 true;
    gte r72.size r4 into r74;
    assert.eq r74 true;
    gte r72.collateral r3 into r75;
    assert.eq r75 true;
    mul r72.reserve_amount r4 into r76;
    div r76 r72.size into r77;
    is.eq r72.size r4 into r78;
    sub r72.reserve_amount r77 into r79;
    ternary r78 0u128 r79 into r80;
    get reserve_amounts[r1] into r81;
    sub r81 r77 into r82;
    set r82 into reserve_amounts[r1];
    get cumulative_funding_rates[r1] into r83;
    is.eq r4 0u128 into r84;
    sub 10000u128 10u128 into r85;
    mul r4 r85 into r86;
    div r86 10000u128 into r87;
    sub r4 r87 into r88;
    ternary r84 0u128 r88 into r89;
    sub r83 r72.entry_funding_rate into r90;
    is.eq r72.size 0u128 into r91;
    is.eq r90 0u128 into r92;
    or r91 r92 into r93;
    mul r72.size r90 into r94;
    div r94 1000000u128 into r95;
    ternary r93 0u128 r95 into r96;
    add r89 r96 into r97;
    get oracle_perps_v1.aleo/max_price[r1] into r98;
    pow 10u128 6u8 into r99;
    mul r97 r99 into r100;
    div r100 r98 into r101;
    get.or_use fee_reserves[r1] 0u128 into r102;
    add r102 r101 into r103;
    set r103 into fee_reserves[r1];
    ternary r5 r32 r31 into r104;
    contains min_profit_block[true] into r105;
    assert.eq r105 true;
    get min_profit_block[true] into r106;
    add r72.last_increased_block r106 into r107;
    gt block.height r107 into r108;
    get.or_use min_profit_basis_points[r2] 0u32 into r109;
    ternary r108 0u32 r109 into r110;
    gt r72.average_price r104 into r111;
    sub.w r72.average_price r104 into r112;
    sub.w r104 r72.average_price into r113;
    ternary r111 r112 r113 into r114;
    is.eq r72.average_price 0u128 into r115;
    ternary r115 1u128 r72.average_price into r116;
    is.eq r72.average_price 0u128 into r117;
    mul r72.size r114 into r118;
    div.w r118 r116 into r119;
    ternary r117 0u128 r119 into r120;
    gt r104 r72.average_price into r121;
    gt r72.average_price r104 into r122;
    ternary r5 r121 r122 into r123;
    mul r120 10000u128 into r124;
    cast r110 into r125 as u128;
    mul r72.size r125 into r126;
    lte r124 r126 into r127;
    and r123 r127 into r128;
    ternary r128 0u128 r120 into r129;
    mul r4 r129 into r130;
    div r130 r72.size into r131;
    ternary r123 r131 0u128 into r132;
    cast r131 into r133 as i128;
    add r72.realised_pnl r133 into r134;
    cast r131 into r135 as i128;
    sub.w r72.realised_pnl r135 into r136;
    ternary r123 r134 r136 into r137;
    sub.w r72.collateral r131 into r138;
    ternary r123 r72.collateral r138 into r139;
    add r132 r3 into r140;
    sub r139 r3 into r141;
    is.eq r72.size r4 into r142;
    add r140 r141 into r143;
    ternary r142 r143 r140 into r144;
    is.eq r72.size r4 into r145;
    ternary r145 0u128 r141 into r146;
    pow 10u128 6u8 into r147;
    mul r131 r147 into r148;
    div r148 r98 into r149;
    sub.w r46 r149 into r150;
    add r46 r149 into r151;
    ternary r123 r150 r151 into r152;
    ternary r5 r46 r152 into r153;
    set r153 into pool_amounts[r1];
    gt r144 r97 into r154;
    sub.w r144 r97 into r155;
    ternary r154 r155 r144 into r156;
    lte r144 r97 into r157;
    sub.w r146 r97 into r158;
    ternary r157 r158 r146 into r159;
    lte r144 r97 into r160;
    and r160 r5 into r161;
    ternary r161 r101 0u128 into r162;
    get pool_amounts[r1] into r163;
    sub r163 r162 into r164;
    set r164 into pool_amounts[r1];
    get.or_use reserve_amounts[r1] 0u128 into r165;
    get pool_amounts[r1] into r166;
    lte r165 r166 into r167;
    assert.eq r167 true;
    is.eq r72.size r4 into r168;
    sub r72.size r4 into r169;
    ternary r168 0u128 r169 into r170;
    is.eq r72.size r4 into r171;
    ternary r171 0u128 r83 into r172;
    is.eq r72.size r4 into r173;
    ternary r173 0u128 r72.average_price into r174;
    is.eq r72.size r4 into r175;
    ternary r175 0u32 r72.last_increased_block into r176;
    cast r170 r159 r174 r172 r80 r137 r176 into r177 as Position;
    set r177 into positions[r71];
    get positions[r71] into r178;
    gte r170 r159 into r179;
    assert.eq r179 true;
    gt r178.average_price r104 into r180;
    sub.w r178.average_price r104 into r181;
    sub.w r104 r178.average_price into r182;
    ternary r180 r181 r182 into r183;
    is.eq r178.average_price 0u128 into r184;
    ternary r184 1u128 r178.average_price into r185;
    is.eq r178.average_price 0u128 into r186;
    mul r178.size r183 into r187;
    div.w r187 r185 into r188;
    ternary r186 0u128 r188 into r189;
    gt r104 r178.average_price into r190;
    gt r178.average_price r104 into r191;
    ternary r5 r190 r191 into r192;
    mul r189 10000u128 into r193;
    cast r110 into r194 as u128;
    mul r178.size r194 into r195;
    lte r193 r195 into r196;
    and r192 r196 into r197;
    ternary r197 0u128 r189 into r198;
    is.eq r178.size 0u128 into r199;
    sub 10000u128 10u128 into r200;
    mul r178.size r200 into r201;
    div r201 10000u128 into r202;
    sub r178.size r202 into r203;
    ternary r199 0u128 r203 into r204;
    sub r83 r178.entry_funding_rate into r205;
    is.eq r178.size 0u128 into r206;
    is.eq r205 0u128 into r207;
    or r206 r207 into r208;
    mul r178.size r205 into r209;
    div r209 1000000u128 into r210;
    ternary r208 0u128 r210 into r211;
    add r204 r211 into r212;
    not r192 into r213;
    gte r159 r198 into r214;
    and r213 r214 into r215;
    sub.w r159 r198 into r216;
    ternary r215 r216 0u128 into r217;
    ternary r192 r159 r217 into r218;
    is.neq r218 0u128 into r219;
    lt r218 r212 into r220;
    and r219 r220 into r221;
    is.neq r218 0u128 into r222;
    gte r218 r212 into r223;
    and r222 r223 into r224;
    add r212 5000000u128 into r225;
    lt r218 r225 into r226;
    and r224 r226 into r227;
    is.neq r218 0u128 into r228;
    add r212 5000000u128 into r229;
    gte r218 r229 into r230;
    and r228 r230 into r231;
    mul r218 500000u128 into r232;
    mul r170 10000u128 into r233;
    lt r232 r233 into r234;
    and r231 r234 into r235;
    is.eq r218 0u128 into r236;
    or r236 r221 into r237;
    or r237 r227 into r238;
    ternary r235 2u8 0u8 into r239;
    ternary r238 1u8 r239 into r240;
    ternary r221 r218 r212 into r241;
    is.eq r72.size r4 into r242;
    ternary r242 0u8 r240 into r243;
    is.eq r243 0u8 into r244;
    assert.eq r244 true;
    get.or_use guaranteed_usd[r1] 0u128 into r245;
    is.neq r72.size r4 into r246;
    and r5 r246 into r247;
    add r245 r72.collateral into r248;
    sub.w r248 r178.collateral into r249;
    sub.w r249 r4 into r250;
    is.eq r72.size r4 into r251;
    and r5 r251 into r252;
    add r245 r72.collateral into r253;
    sub.w r253 r4 into r254;
    ternary r252 r254 r245 into r255;
    ternary r247 r250 r255 into r256;
    set r256 into guaranteed_usd[r1];
    get.or_use global_short_sizes[r2] 0u128 into r257;
    not r5 into r258;
    gt r4 r257 into r259;
    and r258 r259 into r260;
    not r5 into r261;
    lte r4 r257 into r262;
    and r261 r262 into r263;
    sub.w r257 r4 into r264;
    ternary r263 r264 r257 into r265;
    ternary r260 0u128 r265 into r266;
    set r266 into global_short_sizes[r2];
    get pool_amounts[r1] into r267;
    pow 10u128 6u8 into r268;
    mul r144 r268 into r269;
    div r269 r98 into r270;
    gt r144 0u128 into r271;
    and r271 r5 into r272;
    sub.w r267 r270 into r273;
    ternary r272 r273 r267 into r274;
    set r274 into pool_amounts[r1];
    pow 10u128 6u8 into r275;
    mul r156 r275 into r276;
    div r276 r98 into r277;
    cast r1 r6 into r278 as AccountKey;
    hash.bhp256 r278 into r279 as field;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r280 as AccountKey;
    hash.bhp256 r280 into r281 as field;
    get.or_use account[r279] 0u128 into r282;
    add r282 r277 into r283;
    set r283 into account[r279];
    get account[r281] into r284;
    sub r284 r277 into r285;
    set r285 into account[r281];


function liquidate_position:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as boolean.public;
    input r4 as address.public;
    async liquidate_position self.caller r0 r1 r2 r3 r4 into r5;
    output r5 as pool_perps_v1.aleo/liquidate_position.future;

finalize liquidate_position:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as field.public;
    input r3 as field.public;
    input r4 as boolean.public;
    input r5 as address.public;
    contains whitelist_token_ids[true] into r6;
    assert.eq r6 true;
    get whitelist_token_ids[true] into r7;
    is.eq r7[0u32] r2 into r8;
    is.eq r7[1u32] r2 into r9;
    or r8 r9 into r10;
    is.eq r7[2u32] r2 into r11;
    or r10 r11 into r12;
    is.eq r7[3u32] r2 into r13;
    or r12 r13 into r14;
    is.eq r7[4u32] r2 into r15;
    or r14 r15 into r16;
    assert.eq r16 true;
    get whitelist_token_ids[true] into r17;
    is.eq r17[0u32] r3 into r18;
    is.eq r17[1u32] r3 into r19;
    or r18 r19 into r20;
    is.eq r17[2u32] r3 into r21;
    or r20 r21 into r22;
    is.eq r17[3u32] r3 into r23;
    or r22 r23 into r24;
    is.eq r17[4u32] r3 into r25;
    or r24 r25 into r26;
    assert.eq r26 true;
    contains tokens[r2] into r27;
    assert.eq r27 true;
    contains tokens[r3] into r28;
    assert.eq r28 true;
    contains in_private_liquidation_mode[true] into r29;
    assert.eq r29 true;
    get in_private_liquidation_mode[true] into r30;
    get.or_use is_liquidator[r0] false into r31;
    ternary r30 r31 true into r32;
    assert.eq r32 true;
    get.or_use last_funding_blocks[r2] 0u32 into r33;
    div block.height 5760u32 into r34;
    mul r34 5760u32 into r35;
    is.eq r33 0u32 into r36;
    is.neq r33 0u32 into r37;
    add r33 5760u32 into r38;
    gt r38 block.height into r39;
    and r37 r39 into r40;
    ternary r40 r33 r35 into r41;
    ternary r36 r35 r41 into r42;
    get.or_use pool_amounts[r2] 0u128 into r43;
    sub block.height r33 into r44;
    div r44 5760u32 into r45;
    contains funding_rate_config[true] into r46;
    assert.eq r46 true;
    get funding_rate_config[true] into r47;
    get stable_tokens[r2] into r48;
    ternary r48 r47.stable_funding_rate_factor r47.funding_rate_factor into r49;
    is.eq r43 0u128 into r50;
    add r33 5760u32 into r51;
    gt r51 block.height into r52;
    or r50 r52 into r53;
    ternary r53 1u128 r43 into r54;
    is.eq r43 0u128 into r55;
    add r33 5760u32 into r56;
    gt r56 block.height into r57;
    or r55 r57 into r58;
    get.or_use reserve_amounts[r2] 0u128 into r59;
    mul r49 r59 into r60;
    cast r45 into r61 as u128;
    mul r60 r61 into r62;
    div.w r62 r54 into r63;
    ternary r58 0u128 r63 into r64;
    get.or_use cumulative_funding_rates[r2] 0u128 into r65;
    add r65 r64 into r66;
    set r66 into cumulative_funding_rates[r2];
    set r42 into last_funding_blocks[r2];
    cast r1 r2 r3 r4 into r67 as PositionKey;
    hash.bhp256 r67 into r68 as field;
    get positions[r68] into r69;
    gt r69.size 0u128 into r70;
    assert.eq r70 true;
    get oracle_perps_v1.aleo/max_price[r3] into r71;
    get oracle_perps_v1.aleo/min_price[r3] into r72;
    ternary r4 r72 r71 into r73;
    contains min_profit_block[true] into r74;
    assert.eq r74 true;
    get min_profit_block[true] into r75;
    add r69.last_increased_block r75 into r76;
    gt block.height r76 into r77;
    get.or_use min_profit_basis_points[r3] 0u32 into r78;
    ternary r77 0u32 r78 into r79;
    gt r69.average_price r73 into r80;
    sub.w r69.average_price r73 into r81;
    sub.w r73 r69.average_price into r82;
    ternary r80 r81 r82 into r83;
    is.eq r69.average_price 0u128 into r84;
    ternary r84 1u128 r69.average_price into r85;
    is.eq r69.average_price 0u128 into r86;
    mul r69.size r83 into r87;
    div.w r87 r85 into r88;
    ternary r86 0u128 r88 into r89;
    gt r73 r69.average_price into r90;
    gt r69.average_price r73 into r91;
    ternary r4 r90 r91 into r92;
    mul r89 10000u128 into r93;
    cast r79 into r94 as u128;
    mul r69.size r94 into r95;
    lte r93 r95 into r96;
    and r92 r96 into r97;
    ternary r97 0u128 r89 into r98;
    get cumulative_funding_rates[r2] into r99;
    is.eq r69.size 0u128 into r100;
    sub 10000u128 10u128 into r101;
    mul r69.size r101 into r102;
    div r102 10000u128 into r103;
    sub r69.size r103 into r104;
    ternary r100 0u128 r104 into r105;
    sub r99 r69.entry_funding_rate into r106;
    is.eq r69.size 0u128 into r107;
    is.eq r106 0u128 into r108;
    or r107 r108 into r109;
    mul r69.size r106 into r110;
    div r110 1000000u128 into r111;
    ternary r109 0u128 r111 into r112;
    add r105 r112 into r113;
    not r92 into r114;
    gte r69.collateral r98 into r115;
    and r114 r115 into r116;
    sub.w r69.collateral r98 into r117;
    ternary r116 r117 0u128 into r118;
    ternary r92 r69.collateral r118 into r119;
    is.neq r119 0u128 into r120;
    lt r119 r113 into r121;
    and r120 r121 into r122;
    is.neq r119 0u128 into r123;
    gte r119 r113 into r124;
    and r123 r124 into r125;
    add r113 5000000u128 into r126;
    lt r119 r126 into r127;
    and r125 r127 into r128;
    is.neq r119 0u128 into r129;
    add r113 5000000u128 into r130;
    gte r119 r130 into r131;
    and r129 r131 into r132;
    mul r119 500000u128 into r133;
    mul r69.size 10000u128 into r134;
    lt r133 r134 into r135;
    and r132 r135 into r136;
    is.eq r119 0u128 into r137;
    or r137 r122 into r138;
    or r138 r128 into r139;
    ternary r136 2u8 0u8 into r140;
    ternary r139 1u8 r140 into r141;
    ternary r122 r119 r113 into r142;
    is.neq r141 0u8 into r143;
    assert.eq r143 true;
    get oracle_perps_v1.aleo/max_price[r2] into r144;
    is.eq r141 2u8 into r145;
    and r145 r92 into r146;
    gt r98 0u128 into r147;
    and r146 r147 into r148;
    ternary r148 r98 0u128 into r149;
    is.eq r141 2u8 into r150;
    not r92 into r151;
    and r150 r151 into r152;
    gt r98 0u128 into r153;
    and r152 r153 into r154;
    sub.w r69.collateral r98 into r155;
    ternary r154 r155 r69.collateral into r156;
    is.eq r141 2u8 into r157;
    add r149 r156 into r158;
    ternary r157 r158 0u128 into r159;
    is.eq r141 2u8 into r160;
    sub.w r159 r113 into r161;
    ternary r160 r161 0u128 into r162;
    is.eq r141 2u8 into r163;
    pow 10u128 6u8 into r164;
    mul r162 r164 into r165;
    div r165 r144 into r166;
    ternary r163 r166 0u128 into r167;
    get pool_amounts[r2] into r168;
    is.eq r141 2u8 into r169;
    and r169 r92 into r170;
    gt r98 0u128 into r171;
    and r170 r171 into r172;
    not r4 into r173;
    and r172 r173 into r174;
    is.eq r141 2u8 into r175;
    not r92 into r176;
    and r175 r176 into r177;
    gt r98 0u128 into r178;
    and r177 r178 into r179;
    not r4 into r180;
    and r179 r180 into r181;
    pow 10u128 6u8 into r182;
    mul r98 r182 into r183;
    div r183 r144 into r184;
    sub.w r168 r184 into r185;
    add r168 r184 into r186;
    ternary r181 r186 r168 into r187;
    ternary r174 r185 r187 into r188;
    set r188 into pool_amounts[r2];
    is.eq r141 2u8 into r189;
    gt r159 0u128 into r190;
    and r189 r190 into r191;
    and r191 r4 into r192;
    pow 10u128 6u8 into r193;
    mul r159 r193 into r194;
    div r194 r144 into r195;
    ternary r192 r195 0u128 into r196;
    get pool_amounts[r2] into r197;
    sub r197 r196 into r198;
    set r198 into pool_amounts[r2];
    cast r2 r1 into r199 as AccountKey;
    hash.bhp256 r199 into r200 as field;
    get account[r200] into r201;
    add r201 r167 into r202;
    set r202 into account[r200];
    cast r2 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r203 as AccountKey;
    hash.bhp256 r203 into r204 as field;
    get account[r204] into r205;
    sub r205 r167 into r206;
    set r206 into account[r204];
    pow 10u128 6u8 into r207;
    mul r113 r207 into r208;
    div r208 r144 into r209;
    pow 10u128 6u8 into r210;
    mul r142 r210 into r211;
    div r211 r144 into r212;
    is.eq r141 2u8 into r213;
    ternary r213 r209 r212 into r214;
    get.or_use fee_reserves[r2] 0u128 into r215;
    add r215 r214 into r216;
    set r216 into fee_reserves[r2];
    is.eq r141 1u8 into r217;
    and r217 r4 into r218;
    ternary r218 r212 0u128 into r219;
    get pool_amounts[r2] into r220;
    sub r220 r219 into r221;
    set r221 into pool_amounts[r2];
    is.eq r141 1u8 into r222;
    not r4 into r223;
    and r222 r223 into r224;
    lt r142 r69.collateral into r225;
    and r224 r225 into r226;
    sub.w r69.collateral r142 into r227;
    pow 10u128 6u8 into r228;
    mul r227 r228 into r229;
    div r229 r144 into r230;
    ternary r226 r230 0u128 into r231;
    get pool_amounts[r2] into r232;
    add r232 r231 into r233;
    set r233 into pool_amounts[r2];
    is.eq r141 1u8 into r234;
    pow 10u128 6u8 into r235;
    mul 5000000u128 r235 into r236;
    div r236 r144 into r237;
    ternary r234 r237 0u128 into r238;
    get pool_amounts[r2] into r239;
    sub r239 r238 into r240;
    set r240 into pool_amounts[r2];
    cast r2 r5 into r241 as AccountKey;
    hash.bhp256 r241 into r242 as field;
    get.or_use account[r242] 0u128 into r243;
    add r243 r238 into r244;
    set r244 into account[r242];
    get account[r204] into r245;
    sub r245 r238 into r246;
    set r246 into account[r204];
    get reserve_amounts[r2] into r247;
    sub r247 r69.reserve_amount into r248;
    set r248 into reserve_amounts[r2];
    get.or_use guaranteed_usd[r2] 0u128 into r249;
    add r249 r69.collateral into r250;
    sub.w r250 r69.size into r251;
    ternary r4 r251 r249 into r252;
    set r252 into guaranteed_usd[r2];
    get.or_use global_short_sizes[r3] 0u128 into r253;
    not r4 into r254;
    gt r253 r69.size into r255;
    and r254 r255 into r256;
    sub.w r253 r69.size into r257;
    not r4 into r258;
    lte r253 r69.size into r259;
    and r258 r259 into r260;
    ternary r260 0u128 r253 into r261;
    ternary r256 r257 r261 into r262;
    set r262 into global_short_sizes[r3];
    remove positions[r68];


function swap:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0 r2 into r5;
    assert.eq r5 true;
    is.neq r0 5831693778411205416925069027464809696308596398099265250571387651489705378046field into r6;
    assert.eq r6 true;
    is.neq r2 5831693778411205416925069027464809696308596398099265250571387651489705378046field into r7;
    assert.eq r7 true;
    is.neq r0 6769995254802454894577392401849975163810476770055238272962759031196088045850field into r8;
    assert.eq r8 true;
    is.neq r2 6769995254802454894577392401849975163810476770055238272962759031196088045850field into r9;
    assert.eq r9 true;
    gt r1 0u128 into r10;
    assert.eq r10 true;
    async swap self.caller r0 r1 r2 r3 r4 into r11;
    output r11 as pool_perps_v1.aleo/swap.future;

finalize swap:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as field.public;
    input r4 as u128.public;
    input r5 as address.public;
    contains tokens[r1] into r6;
    assert.eq r6 true;
    contains tokens[r3] into r7;
    assert.eq r7 true;
    contains is_swap_enabled[true] into r8;
    assert.eq r8 true;
    get is_swap_enabled[true] into r9;
    assert.eq r9 true;
    contains whitelist_token_ids[true] into r10;
    assert.eq r10 true;
    get whitelist_token_ids[true] into r11;
    is.eq r11[0u32] r1 into r12;
    is.eq r11[1u32] r1 into r13;
    or r12 r13 into r14;
    is.eq r11[2u32] r1 into r15;
    or r14 r15 into r16;
    is.eq r11[3u32] r1 into r17;
    or r16 r17 into r18;
    is.eq r11[4u32] r1 into r19;
    or r18 r19 into r20;
    assert.eq r20 true;
    get whitelist_token_ids[true] into r21;
    is.eq r21[0u32] r3 into r22;
    is.eq r21[1u32] r3 into r23;
    or r22 r23 into r24;
    is.eq r21[2u32] r3 into r25;
    or r24 r25 into r26;
    is.eq r21[3u32] r3 into r27;
    or r26 r27 into r28;
    is.eq r21[4u32] r3 into r29;
    or r28 r29 into r30;
    assert.eq r30 true;
    cast r1 r0 into r31 as AccountKey;
    hash.bhp256 r31 into r32 as field;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r33 as AccountKey;
    hash.bhp256 r33 into r34 as field;
    get account[r32] into r35;
    gte r35 r2 into r36;
    assert.eq r36 true;
    sub r35 r2 into r37;
    set r37 into account[r32];
    get.or_use account[r34] 0u128 into r38;
    add r38 r2 into r39;
    set r39 into account[r34];
    get.or_use last_funding_blocks[r1] 0u32 into r40;
    div block.height 5760u32 into r41;
    mul r41 5760u32 into r42;
    is.eq r40 0u32 into r43;
    is.neq r40 0u32 into r44;
    add r40 5760u32 into r45;
    gt r45 block.height into r46;
    and r44 r46 into r47;
    ternary r47 r40 r42 into r48;
    ternary r43 r42 r48 into r49;
    get.or_use pool_amounts[r1] 0u128 into r50;
    sub block.height r40 into r51;
    div r51 5760u32 into r52;
    contains funding_rate_config[true] into r53;
    assert.eq r53 true;
    get funding_rate_config[true] into r54;
    get stable_tokens[r1] into r55;
    ternary r55 r54.stable_funding_rate_factor r54.funding_rate_factor into r56;
    is.eq r50 0u128 into r57;
    add r40 5760u32 into r58;
    gt r58 block.height into r59;
    or r57 r59 into r60;
    ternary r60 1u128 r50 into r61;
    is.eq r50 0u128 into r62;
    add r40 5760u32 into r63;
    gt r63 block.height into r64;
    or r62 r64 into r65;
    get.or_use reserve_amounts[r1] 0u128 into r66;
    mul r56 r66 into r67;
    cast r52 into r68 as u128;
    mul r67 r68 into r69;
    div.w r69 r61 into r70;
    ternary r65 0u128 r70 into r71;
    get.or_use cumulative_funding_rates[r1] 0u128 into r72;
    add r72 r71 into r73;
    set r73 into cumulative_funding_rates[r1];
    set r49 into last_funding_blocks[r1];
    get.or_use last_funding_blocks[r3] 0u32 into r74;
    is.eq r74 0u32 into r75;
    is.neq r74 0u32 into r76;
    add r74 5760u32 into r77;
    gt r77 block.height into r78;
    and r76 r78 into r79;
    ternary r79 r74 r42 into r80;
    ternary r75 r42 r80 into r81;
    get.or_use pool_amounts[r3] 0u128 into r82;
    sub block.height r74 into r83;
    div r83 5760u32 into r84;
    get stable_tokens[r3] into r85;
    ternary r85 r54.stable_funding_rate_factor r54.funding_rate_factor into r86;
    is.eq r82 0u128 into r87;
    add r74 5760u32 into r88;
    gt r88 block.height into r89;
    or r87 r89 into r90;
    ternary r90 1u128 r82 into r91;
    is.eq r82 0u128 into r92;
    add r74 5760u32 into r93;
    gt r93 block.height into r94;
    or r92 r94 into r95;
    get.or_use reserve_amounts[r3] 0u128 into r96;
    mul r86 r96 into r97;
    cast r84 into r98 as u128;
    mul r97 r98 into r99;
    div r99 r91 into r100;
    ternary r95 0u128 r100 into r101;
    get.or_use cumulative_funding_rates[r3] 0u128 into r102;
    add r102 r101 into r103;
    set r103 into cumulative_funding_rates[r3];
    set r81 into last_funding_blocks[r3];
    get oracle_perps_v1.aleo/min_price[r1] into r104;
    get oracle_perps_v1.aleo/max_price[r3] into r105;
    mul r2 r104 into r106;
    div r106 r105 into r107;
    mul r2 r104 into r108;
    pow 10u128 6u8 into r109;
    div r108 r109 into r110;
    get stable_tokens[r1] into r111;
    get stable_tokens[r3] into r112;
    and r111 r112 into r113;
    ternary r113 4u128 30u128 into r114;
    ternary r113 20u128 50u128 into r115;
    get tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field] into r116;
    get.or_use usda_amounts[r1] 0u128 into r117;
    contains total_token_weights[true] into r118;
    assert.eq r118 true;
    get total_token_weights[true] into r119;
    is.eq r119 0u128 into r120;
    ternary r120 1u128 r119 into r121;
    get.or_use token_weights[r1] 0u128 into r122;
    mul r122 r116.total_supply into r123;
    div r123 r121 into r124;
    add r117 r110 into r125;
    gt r110 r117 into r126;
    sub.w r117 r110 into r127;
    ternary r126 0u128 r127 into r128;
    ternary true r125 r128 into r129;
    gt r117 r124 into r130;
    sub.w r117 r124 into r131;
    sub.w r124 r117 into r132;
    ternary r130 r131 r132 into r133;
    gt r129 r124 into r134;
    sub.w r129 r124 into r135;
    sub.w r124 r129 into r136;
    ternary r134 r135 r136 into r137;
    is.neq r124 0u128 into r138;
    lt r137 r133 into r139;
    and r138 r139 into r140;
    ternary r140 r124 1u128 into r141;
    lt r137 r133 into r142;
    is.neq r124 0u128 into r143;
    and r142 r143 into r144;
    mul r115 r133 into r145;
    div r145 r141 into r146;
    ternary r144 r146 0u128 into r147;
    lt r137 r133 into r148;
    lte r147 r114 into r149;
    and r148 r149 into r150;
    sub.w r114 r147 into r151;
    ternary r150 r151 0u128 into r152;
    gt r137 r133 into r153;
    add r133 r137 into r154;
    div r154 2u128 into r155;
    ternary r153 r155 0u128 into r156;
    gt r156 r124 into r157;
    ternary r157 r124 r156 into r158;
    is.eq r124 0u128 into r159;
    ternary r159 2u128 r124 into r160;
    not false into r161;
    is.eq r124 0u128 into r162;
    or r161 r162 into r163;
    lt r137 r133 into r164;
    mul r115 r158 into r165;
    div r165 r160 into r166;
    add r114 r166 into r167;
    ternary r164 r152 r167 into r168;
    ternary r163 r114 r168 into r169;
    get.or_use usda_amounts[r3] 0u128 into r170;
    get.or_use token_weights[r3] 0u128 into r171;
    mul r171 r116.total_supply into r172;
    div r172 r121 into r173;
    add r170 r110 into r174;
    gt r110 r170 into r175;
    sub.w r170 r110 into r176;
    ternary r175 0u128 r176 into r177;
    ternary false r174 r177 into r178;
    gt r170 r173 into r179;
    sub.w r170 r173 into r180;
    sub.w r173 r170 into r181;
    ternary r179 r180 r181 into r182;
    gt r178 r173 into r183;
    sub.w r178 r173 into r184;
    sub.w r173 r178 into r185;
    ternary r183 r184 r185 into r186;
    is.neq r173 0u128 into r187;
    lt r186 r182 into r188;
    and r187 r188 into r189;
    ternary r189 r173 1u128 into r190;
    lt r186 r182 into r191;
    is.neq r173 0u128 into r192;
    and r191 r192 into r193;
    mul r115 r182 into r194;
    div r194 r190 into r195;
    ternary r193 r195 0u128 into r196;
    lt r186 r182 into r197;
    lte r196 r114 into r198;
    and r197 r198 into r199;
    sub.w r114 r196 into r200;
    ternary r199 r200 0u128 into r201;
    gt r186 r182 into r202;
    add r182 r186 into r203;
    div r203 2u128 into r204;
    ternary r202 r204 0u128 into r205;
    gt r205 r173 into r206;
    ternary r206 r173 r205 into r207;
    is.eq r173 0u128 into r208;
    ternary r208 2u128 r173 into r209;
    not false into r210;
    is.eq r173 0u128 into r211;
    or r210 r211 into r212;
    lt r186 r182 into r213;
    mul r115 r207 into r214;
    div r214 r209 into r215;
    add r114 r215 into r216;
    ternary r213 r201 r216 into r217;
    ternary r212 r114 r217 into r218;
    gt r169 r218 into r219;
    ternary r219 r169 r218 into r220;
    sub 10000u128 r220 into r221;
    mul r107 r221 into r222;
    div r222 10000u128 into r223;
    sub r107 r223 into r224;
    get.or_use fee_reserves[r3] 0u128 into r225;
    add r225 r224 into r226;
    set r226 into fee_reserves[r3];
    get.or_use usda_amounts[r1] 0u128 into r227;
    add r227 r110 into r228;
    set r228 into usda_amounts[r1];
    get.or_use max_usda_amounts[r1] 0u128 into r229;
    gt r229 0u128 into r230;
    get usda_amounts[r1] into r231;
    lte r231 r229 into r232;
    ternary r230 r232 true into r233;
    assert.eq r233 true;
    get.or_use usda_amounts[r3] 0u128 into r234;
    lte r234 r110 into r235;
    sub.w r234 r110 into r236;
    ternary r235 0u128 r236 into r237;
    set r237 into usda_amounts[r3];
    get.or_use pool_amounts[r1] 0u128 into r238;
    add r238 r2 into r239;
    set r239 into pool_amounts[r1];
    get pool_amounts[r1] into r240;
    get account[r34] into r241;
    lte r240 r241 into r242;
    assert.eq r242 true;
    get pool_amounts[r3] into r243;
    sub r243 r107 into r244;
    set r244 into pool_amounts[r3];
    get.or_use reserve_amounts[r3] 0u128 into r245;
    get pool_amounts[r3] into r246;
    lte r245 r246 into r247;
    assert.eq r247 true;
    gte r223 r4 into r248;
    assert.eq r248 true;
    cast r3 r5 into r249 as AccountKey;
    hash.bhp256 r249 into r250 as field;
    cast r3 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r251 as AccountKey;
    hash.bhp256 r251 into r252 as field;
    get.or_use account[r250] 0u128 into r253;
    add r253 r223 into r254;
    set r254 into account[r250];
    get account[r252] into r255;
    sub r255 r223 into r256;
    set r256 into account[r252];


function buy_usda:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as address.public;
    gt r1 0u128 into r3;
    assert.eq r3 true;
    is.neq r0 5831693778411205416925069027464809696308596398099265250571387651489705378046field into r4;
    assert.eq r4 true;
    is.neq r0 6769995254802454894577392401849975163810476770055238272962759031196088045850field into r5;
    assert.eq r5 true;
    async buy_usda self.caller r0 r1 r2 into r6;
    output r6 as pool_perps_v1.aleo/buy_usda.future;

finalize buy_usda:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as address.public;
    contains in_manager_mode[true] into r4;
    assert.eq r4 true;
    get in_manager_mode[true] into r5;
    get.or_use is_manager[r0] false into r6;
    ternary r5 r6 false into r7;
    assert.eq r7 true;
    contains tokens[r1] into r8;
    assert.eq r8 true;
    contains whitelist_token_ids[true] into r9;
    assert.eq r9 true;
    get whitelist_token_ids[true] into r10;
    is.eq r10[0u32] r1 into r11;
    is.eq r10[1u32] r1 into r12;
    or r11 r12 into r13;
    is.eq r10[2u32] r1 into r14;
    or r13 r14 into r15;
    is.eq r10[3u32] r1 into r16;
    or r15 r16 into r17;
    is.eq r10[4u32] r1 into r18;
    or r17 r18 into r19;
    assert.eq r19 true;
    cast r1 r0 into r20 as AccountKey;
    hash.bhp256 r20 into r21 as field;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r22 as AccountKey;
    hash.bhp256 r22 into r23 as field;
    get.or_use account[r21] 0u128 into r24;
    gte r24 r2 into r25;
    assert.eq r25 true;
    sub r24 r2 into r26;
    set r26 into account[r21];
    get.or_use account[r23] 0u128 into r27;
    add r27 r2 into r28;
    set r28 into account[r23];
    get.or_use last_funding_blocks[r1] 0u32 into r29;
    div block.height 5760u32 into r30;
    mul r30 5760u32 into r31;
    is.eq r29 0u32 into r32;
    is.neq r29 0u32 into r33;
    add r29 5760u32 into r34;
    gt r34 block.height into r35;
    and r33 r35 into r36;
    ternary r36 r29 r31 into r37;
    ternary r32 r31 r37 into r38;
    get.or_use pool_amounts[r1] 0u128 into r39;
    sub block.height r29 into r40;
    div r40 5760u32 into r41;
    contains funding_rate_config[true] into r42;
    assert.eq r42 true;
    get funding_rate_config[true] into r43;
    get stable_tokens[r1] into r44;
    ternary r44 r43.stable_funding_rate_factor r43.funding_rate_factor into r45;
    is.eq r39 0u128 into r46;
    add r29 5760u32 into r47;
    gt r47 block.height into r48;
    or r46 r48 into r49;
    ternary r49 1u128 r39 into r50;
    is.eq r39 0u128 into r51;
    add r29 5760u32 into r52;
    gt r52 block.height into r53;
    or r51 r53 into r54;
    get.or_use reserve_amounts[r1] 0u128 into r55;
    mul r45 r55 into r56;
    cast r41 into r57 as u128;
    mul r56 r57 into r58;
    div.w r58 r50 into r59;
    ternary r54 0u128 r59 into r60;
    get.or_use cumulative_funding_rates[r1] 0u128 into r61;
    add r61 r60 into r62;
    set r62 into cumulative_funding_rates[r1];
    set r38 into last_funding_blocks[r1];
    get oracle_perps_v1.aleo/min_price[r1] into r63;
    mul r2 r63 into r64;
    pow 10u128 6u8 into r65;
    div r64 r65 into r66;
    gt r66 0u128 into r67;
    assert.eq r67 true;
    get.or_use usda_amounts[r1] 0u128 into r68;
    get tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field] into r69;
    contains total_token_weights[true] into r70;
    assert.eq r70 true;
    get total_token_weights[true] into r71;
    is.eq r71 0u128 into r72;
    ternary r72 1u128 r71 into r73;
    get.or_use token_weights[r1] 0u128 into r74;
    mul r74 r69.total_supply into r75;
    div r75 r73 into r76;
    add r68 r66 into r77;
    gt r66 r68 into r78;
    sub.w r68 r66 into r79;
    ternary r78 0u128 r79 into r80;
    ternary true r77 r80 into r81;
    gt r68 r76 into r82;
    sub.w r68 r76 into r83;
    sub.w r76 r68 into r84;
    ternary r82 r83 r84 into r85;
    gt r81 r76 into r86;
    sub.w r81 r76 into r87;
    sub.w r76 r81 into r88;
    ternary r86 r87 r88 into r89;
    is.neq r76 0u128 into r90;
    lt r89 r85 into r91;
    and r90 r91 into r92;
    ternary r92 r76 1u128 into r93;
    lt r89 r85 into r94;
    is.neq r76 0u128 into r95;
    and r94 r95 into r96;
    mul 50u128 r85 into r97;
    div r97 r93 into r98;
    ternary r96 r98 0u128 into r99;
    lt r89 r85 into r100;
    lte r99 30u128 into r101;
    and r100 r101 into r102;
    sub.w 30u128 r99 into r103;
    ternary r102 r103 0u128 into r104;
    gt r89 r85 into r105;
    add r85 r89 into r106;
    div r106 2u128 into r107;
    ternary r105 r107 0u128 into r108;
    gt r108 r76 into r109;
    ternary r109 r76 r108 into r110;
    is.eq r76 0u128 into r111;
    ternary r111 2u128 r76 into r112;
    not false into r113;
    is.eq r76 0u128 into r114;
    or r113 r114 into r115;
    lt r89 r85 into r116;
    mul 50u128 r110 into r117;
    div r117 r112 into r118;
    add 30u128 r118 into r119;
    ternary r116 r104 r119 into r120;
    ternary r115 30u128 r120 into r121;
    sub 10000u128 r121 into r122;
    mul r2 r122 into r123;
    div r123 10000u128 into r124;
    sub r2 r124 into r125;
    get.or_use fee_reserves[r1] 0u128 into r126;
    add r126 r125 into r127;
    set r127 into fee_reserves[r1];
    mul r124 r63 into r128;
    pow 10u128 6u8 into r129;
    div r128 r129 into r130;
    get.or_use usda_amounts[r1] 0u128 into r131;
    add r131 r130 into r132;
    set r132 into usda_amounts[r1];
    get.or_use max_usda_amounts[r1] 0u128 into r133;
    gt r133 0u128 into r134;
    get usda_amounts[r1] into r135;
    lte r135 r133 into r136;
    ternary r134 r136 true into r137;
    assert.eq r137 true;
    get.or_use pool_amounts[r1] 0u128 into r138;
    add r138 r124 into r139;
    set r139 into pool_amounts[r1];
    add r69.total_supply r130 into r140;
    cast r69.name r69.symbol r69.decimals r140 r69.admin into r141 as TokenInfo;
    set r141 into tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field];
    cast 5831693778411205416925069027464809696308596398099265250571387651489705378046field r3 into r142 as AccountKey;
    hash.bhp256 r142 into r143 as field;
    get.or_use account[r143] 0u128 into r144;
    add r144 r130 into r145;
    set r145 into account[r143];


function sell_usda:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as address.public;
    gt r1 0u128 into r3;
    assert.eq r3 true;
    is.neq r0 5831693778411205416925069027464809696308596398099265250571387651489705378046field into r4;
    assert.eq r4 true;
    is.neq r0 6769995254802454894577392401849975163810476770055238272962759031196088045850field into r5;
    assert.eq r5 true;
    async sell_usda self.caller r0 r1 r2 into r6;
    output r6 as pool_perps_v1.aleo/sell_usda.future;

finalize sell_usda:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as address.public;
    contains in_manager_mode[true] into r4;
    assert.eq r4 true;
    get in_manager_mode[true] into r5;
    get.or_use is_manager[r0] false into r6;
    ternary r5 r6 false into r7;
    assert.eq r7 true;
    contains tokens[r1] into r8;
    assert.eq r8 true;
    contains whitelist_token_ids[true] into r9;
    assert.eq r9 true;
    get whitelist_token_ids[true] into r10;
    is.eq r10[0u32] r1 into r11;
    is.eq r10[1u32] r1 into r12;
    or r11 r12 into r13;
    is.eq r10[2u32] r1 into r14;
    or r13 r14 into r15;
    is.eq r10[3u32] r1 into r16;
    or r15 r16 into r17;
    is.eq r10[4u32] r1 into r18;
    or r17 r18 into r19;
    assert.eq r19 true;
    cast 5831693778411205416925069027464809696308596398099265250571387651489705378046field r0 into r20 as AccountKey;
    hash.bhp256 r20 into r21 as field;
    cast 5831693778411205416925069027464809696308596398099265250571387651489705378046field aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r22 as AccountKey;
    hash.bhp256 r22 into r23 as field;
    get account[r21] into r24;
    gte r24 r2 into r25;
    assert.eq r25 true;
    sub r24 r2 into r26;
    set r26 into account[r21];
    get.or_use account[r23] 0u128 into r27;
    add r27 r2 into r28;
    set r28 into account[r23];
    get.or_use last_funding_blocks[r1] 0u32 into r29;
    div block.height 5760u32 into r30;
    mul r30 5760u32 into r31;
    is.eq r29 0u32 into r32;
    is.neq r29 0u32 into r33;
    add r29 5760u32 into r34;
    gt r34 block.height into r35;
    and r33 r35 into r36;
    ternary r36 r29 r31 into r37;
    ternary r32 r31 r37 into r38;
    get.or_use pool_amounts[r1] 0u128 into r39;
    sub block.height r29 into r40;
    div r40 5760u32 into r41;
    contains funding_rate_config[true] into r42;
    assert.eq r42 true;
    get funding_rate_config[true] into r43;
    get stable_tokens[r1] into r44;
    ternary r44 r43.stable_funding_rate_factor r43.funding_rate_factor into r45;
    is.eq r39 0u128 into r46;
    add r29 5760u32 into r47;
    gt r47 block.height into r48;
    or r46 r48 into r49;
    ternary r49 1u128 r39 into r50;
    is.eq r39 0u128 into r51;
    add r29 5760u32 into r52;
    gt r52 block.height into r53;
    or r51 r53 into r54;
    get.or_use reserve_amounts[r1] 0u128 into r55;
    mul r45 r55 into r56;
    cast r41 into r57 as u128;
    mul r56 r57 into r58;
    div.w r58 r50 into r59;
    ternary r54 0u128 r59 into r60;
    get.or_use cumulative_funding_rates[r1] 0u128 into r61;
    add r61 r60 into r62;
    set r62 into cumulative_funding_rates[r1];
    set r38 into last_funding_blocks[r1];
    get oracle_perps_v1.aleo/max_price[r1] into r63;
    pow 10u128 6u8 into r64;
    mul r2 r64 into r65;
    div r65 r63 into r66;
    gt r66 0u128 into r67;
    assert.eq r67 true;
    get.or_use usda_amounts[r1] 0u128 into r68;
    lte r2 r68 into r69;
    sub.w r68 r2 into r70;
    ternary r69 r70 0u128 into r71;
    set r71 into usda_amounts[r1];
    get pool_amounts[r1] into r72;
    gte r72 r66 into r73;
    assert.eq r73 true;
    get pool_amounts[r1] into r74;
    sub r74 r66 into r75;
    set r75 into pool_amounts[r1];
    get pool_amounts[r1] into r76;
    get.or_use reserve_amounts[r1] 0u128 into r77;
    gte r76 r77 into r78;
    assert.eq r78 true;
    get.or_use account[r23] 0u128 into r79;
    gt r79 r2 into r80;
    ternary r80 r2 r79 into r81;
    get tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field] into r82;
    assert.eq r82.admin aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y;
    sub r82.total_supply r81 into r83;
    cast r82.name r82.symbol r82.decimals r83 r82.admin into r84 as TokenInfo;
    set r84 into tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field];
    sub r79 r81 into r85;
    set r85 into account[r23];
    get.or_use usda_amounts[r1] 0u128 into r86;
    contains total_token_weights[true] into r87;
    assert.eq r87 true;
    get total_token_weights[true] into r88;
    is.eq r88 0u128 into r89;
    ternary r89 1u128 r88 into r90;
    get.or_use token_weights[r1] 0u128 into r91;
    mul r91 r82.total_supply into r92;
    div r92 r90 into r93;
    add r86 r2 into r94;
    gt r2 r86 into r95;
    sub.w r86 r2 into r96;
    ternary r95 0u128 r96 into r97;
    ternary false r94 r97 into r98;
    gt r86 r93 into r99;
    sub.w r86 r93 into r100;
    sub.w r93 r86 into r101;
    ternary r99 r100 r101 into r102;
    gt r98 r93 into r103;
    sub.w r98 r93 into r104;
    sub.w r93 r98 into r105;
    ternary r103 r104 r105 into r106;
    is.neq r93 0u128 into r107;
    lt r106 r102 into r108;
    and r107 r108 into r109;
    ternary r109 r93 1u128 into r110;
    lt r106 r102 into r111;
    is.neq r93 0u128 into r112;
    and r111 r112 into r113;
    mul 50u128 r102 into r114;
    div r114 r110 into r115;
    ternary r113 r115 0u128 into r116;
    lt r106 r102 into r117;
    lte r116 30u128 into r118;
    and r117 r118 into r119;
    sub.w 30u128 r116 into r120;
    ternary r119 r120 0u128 into r121;
    gt r106 r102 into r122;
    add r102 r106 into r123;
    div r123 2u128 into r124;
    ternary r122 r124 0u128 into r125;
    gt r125 r93 into r126;
    ternary r126 r93 r125 into r127;
    is.eq r93 0u128 into r128;
    ternary r128 2u128 r93 into r129;
    not false into r130;
    is.eq r93 0u128 into r131;
    or r130 r131 into r132;
    lt r106 r102 into r133;
    mul 50u128 r127 into r134;
    div r134 r129 into r135;
    add 30u128 r135 into r136;
    ternary r133 r121 r136 into r137;
    ternary r132 30u128 r137 into r138;
    sub 10000u128 r138 into r139;
    mul r66 r139 into r140;
    div r140 10000u128 into r141;
    sub r66 r141 into r142;
    get.or_use fee_reserves[r1] 0u128 into r143;
    add r143 r142 into r144;
    set r144 into fee_reserves[r1];
    gt r141 0u128 into r145;
    assert.eq r145 true;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r146 as AccountKey;
    hash.bhp256 r146 into r147 as field;
    get account[r147] into r148;
    sub r148 r141 into r149;
    set r149 into account[r147];
    cast r1 r3 into r150 as AccountKey;
    hash.bhp256 r150 into r151 as field;
    get.or_use account[r151] 0u128 into r152;
    add r152 r141 into r153;
    set r153 into account[r151];


function set_gov:
    input r0 as address.public;
    input r1 as boolean.public;
    assert.eq self.caller aleo1cnm2w8qlrhahlsmalph7t0jh3adny5pj4m38jgpcdzt2reqthurqaen3dp;
    async set_gov r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_gov.future;

finalize set_gov:
    input r0 as address.public;
    input r1 as boolean.public;
    set r1 into is_gov[r0];


function set_whitelist_token_ids:
    input r0 as [field; 5u32].public;
    async set_whitelist_token_ids self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_whitelist_token_ids.future;

finalize set_whitelist_token_ids:
    input r0 as address.public;
    input r1 as [field; 5u32].public;
    contains whitelist_token_ids[true] into r2;
    not r2 into r3;
    assert.eq r3 true;
    get is_gov[r0] into r4;
    assert.eq r4 true;
    set r1 into whitelist_token_ids[true];


function set_aum_config:
    input r0 as u128.public;
    input r1 as u128.public;
    async set_aum_config self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_aum_config.future;

finalize set_aum_config:
    input r0 as address.public;
    input r1 as u128.public;
    input r2 as u128.public;
    get is_gov[r0] into r3;
    assert.eq r3 true;
    cast r1 r2 into r4 as AumConfig;
    set r4 into aum_config[true];


function set_funding_rate_config:
    input r0 as u128.public;
    input r1 as u128.public;
    async set_funding_rate_config self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_funding_rate_config.future;

finalize set_funding_rate_config:
    input r0 as address.public;
    input r1 as u128.public;
    input r2 as u128.public;
    get is_gov[r0] into r3;
    assert.eq r3 true;
    cast r1 r2 into r4 as FundingRateConfig;
    set r4 into funding_rate_config[true];


function set_token_config:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as u128.public;
    input r3 as u32.public;
    input r4 as boolean.public;
    async set_token_config self.caller r0 r1 r2 r3 r4 into r5;
    output r5 as pool_perps_v1.aleo/set_token_config.future;

finalize set_token_config:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u32.public;
    input r5 as boolean.public;
    get is_gov[r0] into r6;
    assert.eq r6 true;
    contains whitelist_token_ids[true] into r7;
    assert.eq r7 true;
    get whitelist_token_ids[true] into r8;
    is.eq r8[0u32] r1 into r9;
    is.eq r8[1u32] r1 into r10;
    or r9 r10 into r11;
    is.eq r8[2u32] r1 into r12;
    or r11 r12 into r13;
    is.eq r8[3u32] r1 into r14;
    or r13 r14 into r15;
    is.eq r8[4u32] r1 into r16;
    or r15 r16 into r17;
    assert.eq r17 true;
    get.or_use total_token_weights[true] 0u128 into r18;
    add r18 r2 into r19;
    get.or_use token_weights[r1] 0u128 into r20;
    sub r19 r20 into r21;
    set r21 into total_token_weights[true];
    set r5 into stable_tokens[r1];
    set r2 into token_weights[r1];
    set r3 into max_usda_amounts[r1];
    set r4 into min_profit_basis_points[r1];


function set_usda_amount:
    input r0 as field.public;
    input r1 as u128.public;
    async set_usda_amount self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_usda_amount.future;

finalize set_usda_amount:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    get is_gov[r0] into r3;
    assert.eq r3 true;
    get usda_amounts[r1] into r4;
    gt r2 r4 into r5;
    set r2 into usda_amounts[r1];
    get.or_use max_usda_amounts[r1] 0u128 into r6;
    is.neq r6 0u128 into r7;
    and r5 r7 into r8;
    branch.eq r8 false to end_then_0_0;
    lte r2 r6 into r9;
    assert.eq r9 true;
    position end_then_0_0;


function set_min_profit_block:
    input r0 as u32.public;
    async set_min_profit_block self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_min_profit_block.future;

finalize set_min_profit_block:
    input r0 as address.public;
    input r1 as u32.public;
    get is_gov[r0] into r2;
    assert.eq r2 true;
    set r1 into min_profit_block[true];


function set_in_private_liquidation_mode:
    input r0 as boolean.public;
    async set_in_private_liquidation_mode self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_in_private_liquidation_mode.future;

finalize set_in_private_liquidation_mode:
    input r0 as address.public;
    input r1 as boolean.public;
    get is_gov[r0] into r2;
    assert.eq r2 true;
    set r1 into in_private_liquidation_mode[true];


function set_liquidator:
    input r0 as address.public;
    input r1 as boolean.public;
    async set_liquidator self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_liquidator.future;

finalize set_liquidator:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as boolean.public;
    get is_gov[r0] into r3;
    assert.eq r3 true;
    set r2 into is_liquidator[r1];


function set_is_swap_enabled:
    input r0 as boolean.public;
    async set_is_swap_enabled self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_is_swap_enabled.future;

finalize set_is_swap_enabled:
    input r0 as address.public;
    input r1 as boolean.public;
    get is_gov[r0] into r2;
    assert.eq r2 true;
    set r1 into is_swap_enabled[true];


function set_in_manager_mode:
    input r0 as boolean.public;
    async set_in_manager_mode self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_in_manager_mode.future;

finalize set_in_manager_mode:
    input r0 as address.public;
    input r1 as boolean.public;
    get is_gov[r0] into r2;
    assert.eq r2 true;
    set r1 into in_manager_mode[true];


function set_manager:
    input r0 as address.public;
    input r1 as boolean.public;
    async set_manager self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_manager.future;

finalize set_manager:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as boolean.public;
    get is_gov[r0] into r3;
    assert.eq r3 true;
    set r2 into is_manager[r1];


function withdraw_fee:
    input r0 as field.public;
    input r1 as address.public;
    cast r0 r1 into r2 as AccountKey;
    hash.bhp256 r2 into r3 as field;
    cast r0 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r4 as AccountKey;
    hash.bhp256 r4 into r5 as field;
    async withdraw_fee self.caller r0 r3 r5 into r6;
    output r6 as pool_perps_v1.aleo/withdraw_fee.future;

finalize withdraw_fee:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as field.public;
    get is_gov[r0] into r4;
    assert.eq r4 true;
    get.or_use fee_reserves[r1] 0u128 into r5;
    gt r5 0u128 into r6;
    assert.eq r6 true;
    set 0u128 into fee_reserves[r1];
    get.or_use account[r2] 0u128 into r7;
    add r7 r5 into r8;
    set r8 into account[r2];
    get account[r3] into r9;
    sub r9 r5 into r10;
    set r10 into account[r3];
