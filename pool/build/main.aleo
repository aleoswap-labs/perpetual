import oracle_perps_v1.aleo;
program pool_perps_v1.aleo;

struct TokenInfo:
    name as field;
    symbol as field;
    decimals as u8;
    total_supply as u128;
    admin as address;

struct TokenId:
    base as address;
    creator as address;
    salt as u128;

struct AccountKey:
    token_id as field;
    user as address;

struct ApprovalKey:
    token_id as field;
    approver as address;
    spender as address;

struct AumConfig:
    addition as u128;
    deduction as u128;

struct FundingRateConfig:
    stable_funding_rate_factor as u128;
    funding_rate_factor as u128;

struct PositionKey:
    user as address;
    collateral_token_id as field;
    index_token_id as field;
    is_long as boolean;

struct Position:
    size as u128;
    collateral as u128;
    average_price as u128;
    entry_funding_rate as u128;
    reserve_amount as u128;
    realised_pnl as i128;
    last_increased_block as u32;


mapping tokens:
	key as field.public;
	value as TokenInfo.public;


mapping account:
	key as field.public;
	value as u128.public;


mapping approvals:
	key as field.public;
	value as u128.public;


mapping super_admin:
	key as boolean.public;
	value as address.public;


mapping is_governor:
	key as address.public;
	value as boolean.public;


mapping whitelist_token_ids:
	key as boolean.public;
	value as [field; 5u32].public;


mapping cooldown_duration:
	key as boolean.public;
	value as u32.public;


mapping aum_config:
	key as boolean.public;
	value as AumConfig.public;


mapping funding_rate_config:
	key as boolean.public;
	value as FundingRateConfig.public;


mapping stable_tokens:
	key as field.public;
	value as boolean.public;


mapping token_weights:
	key as field.public;
	value as u128.public;


mapping total_token_weights:
	key as boolean.public;
	value as u128.public;


mapping max_usda_amounts:
	key as field.public;
	value as u128.public;


mapping min_profit_basis_points:
	key as field.public;
	value as u32.public;


mapping min_profit_block:
	key as boolean.public;
	value as u32.public;


mapping in_private_liquidation_mode:
	key as boolean.public;
	value as boolean.public;


mapping is_liquidator:
	key as address.public;
	value as boolean.public;


mapping is_swap_enabled:
	key as boolean.public;
	value as boolean.public;


mapping pool_amounts:
	key as field.public;
	value as u128.public;


mapping reserve_amounts:
	key as field.public;
	value as u128.public;


mapping usda_amounts:
	key as field.public;
	value as u128.public;


mapping cumulative_funding_rates:
	key as field.public;
	value as u128.public;


mapping fee_reserves:
	key as field.public;
	value as u128.public;


mapping positions:
	key as field.public;
	value as Position.public;


mapping guaranteed_usd:
	key as field.public;
	value as u128.public;


mapping global_short_sizes:
	key as field.public;
	value as u128.public;


mapping global_short_average_prices:
	key as field.public;
	value as u128.public;


mapping max_global_short_sizes:
	key as field.public;
	value as u128.public;


mapping last_funding_blocks:
	key as field.public;
	value as u32.public;


mapping last_added_at:
	key as address.public;
	value as u32.public;





function init:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as u128.public;
    assert.eq self.caller aleo1cnm2w8qlrhahlsmalph7t0jh3adny5pj4m38jgpcdzt2reqthurqaen3dp;
    cast aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y aleo1cnm2w8qlrhahlsmalph7t0jh3adny5pj4m38jgpcdzt2reqthurqaen3dp r5 into r6 as TokenId;
    hash.bhp256 r6 into r7 as field;
    cast r7 r4 into r8 as AccountKey;
    hash.bhp256 r8 into r9 as field;
    async init r7 r0 r1 r2 r3 r9 into r10;
    output r10 as pool_perps_v1.aleo/init.future;

finalize init:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u8.public;
    input r4 as u128.public;
    input r5 as field.public;
    contains tokens[r0] into r6;
    not r6 into r7;
    assert.eq r7 true;
    cast r1 r2 r3 r4 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r8 as TokenInfo;
    set r8 into tokens[r0];
    set r4 into account[r5];


function create_token:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as u128.public;
    gt r0 0field into r6;
    assert.eq r6 true;
    async create_token r0 r1 r2 r3 r4 self.caller r5 into r7;
    output r7 as pool_perps_v1.aleo/create_token.future;

finalize create_token:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as address.public;
    input r6 as u128.public;
    assert.eq r5 r4;
    cast aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y r5 r6 into r7 as TokenId;
    hash.bhp256 r7 into r8 as field;
    contains tokens[r8] into r9;
    not r9 into r10;
    assert.eq r10 true;
    cast r0 r1 r2 r3 r4 into r11 as TokenInfo;
    set r11 into tokens[r8];
    cast r8 r5 into r12 as AccountKey;
    hash.bhp256 r12 into r13 as field;
    set r3 into account[r13];


function mint:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async mint self.caller r0 r1 r2 into r3;
    output r3 as pool_perps_v1.aleo/mint.future;

finalize mint:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as u128.public;
    get tokens[r1] into r4;
    assert.eq r0 r4.admin;
    pow 10u128 6u8 into r5;
    mul r3 r5 into r6;
    pow 10u128 r4.decimals into r7;
    div r6 r7 into r8;
    add r4.total_supply r8 into r9;
    cast r4.name r4.symbol r4.decimals r9 r4.admin into r10 as TokenInfo;
    set r10 into tokens[r1];
    cast r1 r2 into r11 as AccountKey;
    hash.bhp256 r11 into r12 as field;
    get.or_use account[r12] 0u128 into r13;
    add r13 r8 into r14;
    set r14 into account[r12];




function burn_from:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 r1 self.caller into r3 as ApprovalKey;
    hash.bhp256 r3 into r4 as field;
    async burn_from self.caller r0 r4 r1 r2 into r5;
    output r5 as pool_perps_v1.aleo/burn_from.future;

finalize burn_from:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as address.public;
    input r4 as u128.public;
    get tokens[r1] into r5;
    assert.eq r0 r5.admin;
    pow 10u128 6u8 into r6;
    mul r4 r6 into r7;
    pow 10u128 r5.decimals into r8;
    div r7 r8 into r9;
    get approvals[r2] into r10;
    sub r10 r9 into r11;
    set r11 into approvals[r2];
    sub r5.total_supply r9 into r12;
    cast r5.name r5.symbol r5.decimals r12 r5.admin into r13 as TokenInfo;
    set r13 into tokens[r1];
    cast r1 r3 into r14 as AccountKey;
    hash.bhp256 r14 into r15 as field;
    get account[r15] into r16;
    sub r16 r9 into r17;
    set r17 into account[r15];


function transfer_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async transfer_public r0 self.caller r1 r2 into r3;
    output r3 as pool_perps_v1.aleo/transfer_public.future;

finalize transfer_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    contains tokens[r0] into r4;
    assert.eq r4 true;
    cast r0 r1 into r5 as AccountKey;
    hash.bhp256 r5 into r6 as field;
    get account[r6] into r7;
    sub r7 r3 into r8;
    set r8 into account[r6];
    cast r0 r2 into r9 as AccountKey;
    hash.bhp256 r9 into r10 as field;
    get.or_use account[r10] 0u128 into r11;
    add r11 r3 into r12;
    set r12 into account[r10];


function approve_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 self.caller r1 into r3 as ApprovalKey;
    hash.bhp256 r3 into r4 as field;
    async approve_public r0 r4 r2 into r5;
    output r5 as pool_perps_v1.aleo/approve_public.future;

finalize approve_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true;
    get.or_use approvals[r1] 0u128 into r4;
    sub 340282366920938463463374607431768211455u128 r4 into r5;
    lt r2 r5 into r6;
    add.w r4 r2 into r7;
    ternary r6 r7 340282366920938463463374607431768211455u128 into r8;
    set r8 into approvals[r1];


function unapprove_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 self.caller r1 into r3 as ApprovalKey;
    hash.bhp256 r3 into r4 as field;
    async unapprove_public r0 r4 r2 into r5;
    output r5 as pool_perps_v1.aleo/unapprove_public.future;

finalize unapprove_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true;
    get approvals[r1] into r4;
    gt r4 r2 into r5;
    sub.w r4 r2 into r6;
    ternary r5 r6 0u128 into r7;
    set r7 into approvals[r1];


function transfer_from:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    cast r0 r1 self.caller into r4 as ApprovalKey;
    hash.bhp256 r4 into r5 as field;
    async transfer_from r0 r5 r1 r2 r3 into r6;
    output r6 as pool_perps_v1.aleo/transfer_from.future;

finalize transfer_from:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as address.public;
    input r4 as u128.public;
    contains tokens[r0] into r5;
    assert.eq r5 true;
    get approvals[r1] into r6;
    sub r6 r4 into r7;
    set r7 into approvals[r1];
    cast r0 r2 into r8 as AccountKey;
    hash.bhp256 r8 into r9 as field;
    get account[r9] into r10;
    sub r10 r4 into r11;
    set r11 into account[r9];
    cast r0 r3 into r12 as AccountKey;
    hash.bhp256 r12 into r13 as field;
    get.or_use account[r13] 0u128 into r14;
    add r14 r4 into r15;
    set r15 into account[r13];








function add_liquidity:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as u128.public;
    input r3 as u128.public;
    gt r1 0u128 into r4;
    assert.eq r4 true;
    cast r0 self.caller into r5 as AccountKey;
    hash.bhp256 r5 into r6 as field;
    cast r0 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r7 as AccountKey;
    hash.bhp256 r7 into r8 as field;
    async add_liquidity self.caller r0 r1 r2 r3 r6 r8 into r9;
    output r9 as pool_perps_v1.aleo/add_liquidity.future;

finalize add_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as field.public;
    input r6 as field.public;
    contains tokens[r1] into r7;
    assert.eq r7 true;
    contains whitelist_token_ids[true] into r8;
    assert.eq r8 true;
    get whitelist_token_ids[true] into r9;
    is.eq r9[0u32] r1 into r10;
    is.eq r9[1u32] r1 into r11;
    or r10 r11 into r12;
    is.eq r9[2u32] r1 into r13;
    or r12 r13 into r14;
    is.eq r9[3u32] r1 into r15;
    or r14 r15 into r16;
    is.eq r9[4u32] r1 into r17;
    or r16 r17 into r18;
    assert.eq r18 true;
    get account[r5] into r19;
    sub r19 r2 into r20;
    set r20 into account[r5];
    get.or_use account[r6] 0u128 into r21;
    add r21 r2 into r22;
    set r22 into account[r6];
    contains aum_config[true] into r23;
    assert.eq r23 true;
    get aum_config[true] into r24;
    contains whitelist_token_ids[true] into r25;
    assert.eq r25 true;
    get whitelist_token_ids[true] into r26;
    get oracle_perps_v1.aleo/max_price[r26[0u32]] into r27;
    get.or_use pool_amounts[r26[0u32]] 0u128 into r28;
    get stable_tokens[r26[0u32]] into r29;
    mul r28 r27 into r30;
    pow 10u128 6u8 into r31;
    div r30 r31 into r32;
    add r24.addition r32 into r33;
    ternary r29 r33 r24.addition into r34;
    not r29 into r35;
    get.or_use global_short_sizes[r26[0u32]] 0u128 into r36;
    ternary r35 r36 0u128 into r37;
    not r29 into r38;
    gt r37 0u128 into r39;
    and r38 r39 into r40;
    get.or_use global_short_average_prices[r26[0u32]] 0u128 into r41;
    ternary r40 r41 0u128 into r42;
    gt r42 r27 into r43;
    sub.w r42 r27 into r44;
    sub.w r27 r42 into r45;
    ternary r43 r44 r45 into r46;
    is.eq r42 0u128 into r47;
    ternary r47 1u128 r42 into r48;
    is.neq r42 0u128 into r49;
    mul r37 r46 into r50;
    div.w r50 r48 into r51;
    ternary r49 r51 0u128 into r52;
    gt r42 r27 into r53;
    not r53 into r54;
    add r34 r52 into r55;
    ternary r54 r55 r34 into r56;
    add 0u128 r52 into r57;
    ternary r53 r57 0u128 into r58;
    not r29 into r59;
    get.or_use guaranteed_usd[r26[0u32]] 0u128 into r60;
    add r56 r60 into r61;
    ternary r59 r61 r56 into r62;
    get.or_use reserve_amounts[r26[0u32]] 0u128 into r63;
    not r29 into r64;
    sub.w r28 r63 into r65;
    mul r65 r27 into r66;
    pow 10u128 6u8 into r67;
    div r66 r67 into r68;
    add r62 r68 into r69;
    ternary r64 r69 r62 into r70;
    get oracle_perps_v1.aleo/max_price[r26[1u32]] into r71;
    get.or_use pool_amounts[r26[1u32]] 0u128 into r72;
    get stable_tokens[r26[1u32]] into r73;
    mul r72 r71 into r74;
    pow 10u128 6u8 into r75;
    div r74 r75 into r76;
    add r70 r76 into r77;
    ternary r73 r77 r70 into r78;
    not r73 into r79;
    get.or_use global_short_sizes[r26[1u32]] 0u128 into r80;
    ternary r79 r80 0u128 into r81;
    not r73 into r82;
    gt r81 0u128 into r83;
    and r82 r83 into r84;
    get.or_use global_short_average_prices[r26[1u32]] 0u128 into r85;
    ternary r84 r85 0u128 into r86;
    gt r86 r71 into r87;
    sub.w r86 r71 into r88;
    sub.w r71 r86 into r89;
    ternary r87 r88 r89 into r90;
    is.eq r86 0u128 into r91;
    ternary r91 1u128 r86 into r92;
    is.neq r86 0u128 into r93;
    mul r81 r90 into r94;
    div.w r94 r92 into r95;
    ternary r93 r95 0u128 into r96;
    gt r86 r71 into r97;
    not r97 into r98;
    add r78 r96 into r99;
    ternary r98 r99 r78 into r100;
    add r58 r96 into r101;
    ternary r97 r101 r58 into r102;
    not r73 into r103;
    get.or_use guaranteed_usd[r26[1u32]] 0u128 into r104;
    add r100 r104 into r105;
    ternary r103 r105 r100 into r106;
    get.or_use reserve_amounts[r26[1u32]] 0u128 into r107;
    not r73 into r108;
    sub.w r72 r107 into r109;
    mul r109 r71 into r110;
    pow 10u128 6u8 into r111;
    div r110 r111 into r112;
    add r106 r112 into r113;
    ternary r108 r113 r106 into r114;
    get oracle_perps_v1.aleo/max_price[r26[2u32]] into r115;
    get.or_use pool_amounts[r26[2u32]] 0u128 into r116;
    get stable_tokens[r26[2u32]] into r117;
    mul r116 r115 into r118;
    pow 10u128 6u8 into r119;
    div r118 r119 into r120;
    add r114 r120 into r121;
    ternary r117 r121 r114 into r122;
    not r117 into r123;
    get.or_use global_short_sizes[r26[2u32]] 0u128 into r124;
    ternary r123 r124 0u128 into r125;
    not r117 into r126;
    gt r125 0u128 into r127;
    and r126 r127 into r128;
    get.or_use global_short_average_prices[r26[2u32]] 0u128 into r129;
    ternary r128 r129 0u128 into r130;
    gt r130 r115 into r131;
    sub.w r130 r115 into r132;
    sub.w r115 r130 into r133;
    ternary r131 r132 r133 into r134;
    is.eq r130 0u128 into r135;
    ternary r135 1u128 r130 into r136;
    is.neq r130 0u128 into r137;
    mul r125 r134 into r138;
    div.w r138 r136 into r139;
    ternary r137 r139 0u128 into r140;
    gt r130 r115 into r141;
    not r141 into r142;
    add r122 r140 into r143;
    ternary r142 r143 r122 into r144;
    add r102 r140 into r145;
    ternary r141 r145 r102 into r146;
    not r117 into r147;
    get.or_use guaranteed_usd[r26[2u32]] 0u128 into r148;
    add r144 r148 into r149;
    ternary r147 r149 r144 into r150;
    get.or_use reserve_amounts[r26[2u32]] 0u128 into r151;
    not r117 into r152;
    sub.w r116 r151 into r153;
    mul r153 r115 into r154;
    pow 10u128 6u8 into r155;
    div r154 r155 into r156;
    add r150 r156 into r157;
    ternary r152 r157 r150 into r158;
    get oracle_perps_v1.aleo/max_price[r26[3u32]] into r159;
    get.or_use pool_amounts[r26[3u32]] 0u128 into r160;
    get stable_tokens[r26[3u32]] into r161;
    mul r160 r159 into r162;
    pow 10u128 6u8 into r163;
    div r162 r163 into r164;
    add r158 r164 into r165;
    ternary r161 r165 r158 into r166;
    not r161 into r167;
    get.or_use global_short_sizes[r26[3u32]] 0u128 into r168;
    ternary r167 r168 0u128 into r169;
    not r161 into r170;
    gt r169 0u128 into r171;
    and r170 r171 into r172;
    get.or_use global_short_average_prices[r26[3u32]] 0u128 into r173;
    ternary r172 r173 0u128 into r174;
    gt r174 r159 into r175;
    sub.w r174 r159 into r176;
    sub.w r159 r174 into r177;
    ternary r175 r176 r177 into r178;
    is.eq r174 0u128 into r179;
    ternary r179 1u128 r174 into r180;
    is.neq r174 0u128 into r181;
    mul r169 r178 into r182;
    div.w r182 r180 into r183;
    ternary r181 r183 0u128 into r184;
    gt r174 r159 into r185;
    not r185 into r186;
    add r166 r184 into r187;
    ternary r186 r187 r166 into r188;
    add r146 r184 into r189;
    ternary r185 r189 r146 into r190;
    not r161 into r191;
    get.or_use guaranteed_usd[r26[3u32]] 0u128 into r192;
    add r188 r192 into r193;
    ternary r191 r193 r188 into r194;
    get.or_use reserve_amounts[r26[3u32]] 0u128 into r195;
    not r161 into r196;
    sub.w r160 r195 into r197;
    mul r197 r159 into r198;
    pow 10u128 6u8 into r199;
    div r198 r199 into r200;
    add r194 r200 into r201;
    ternary r196 r201 r194 into r202;
    get oracle_perps_v1.aleo/max_price[r26[4u32]] into r203;
    get.or_use pool_amounts[r26[4u32]] 0u128 into r204;
    get stable_tokens[r26[4u32]] into r205;
    mul r204 r203 into r206;
    pow 10u128 6u8 into r207;
    div r206 r207 into r208;
    add r202 r208 into r209;
    ternary r205 r209 r202 into r210;
    not r205 into r211;
    get.or_use global_short_sizes[r26[4u32]] 0u128 into r212;
    ternary r211 r212 0u128 into r213;
    not r205 into r214;
    gt r213 0u128 into r215;
    and r214 r215 into r216;
    get.or_use global_short_average_prices[r26[4u32]] 0u128 into r217;
    ternary r216 r217 0u128 into r218;
    gt r218 r203 into r219;
    sub.w r218 r203 into r220;
    sub.w r203 r218 into r221;
    ternary r219 r220 r221 into r222;
    is.eq r218 0u128 into r223;
    ternary r223 1u128 r218 into r224;
    is.neq r218 0u128 into r225;
    mul r213 r222 into r226;
    div.w r226 r224 into r227;
    ternary r225 r227 0u128 into r228;
    gt r218 r203 into r229;
    not r229 into r230;
    add r210 r228 into r231;
    ternary r230 r231 r210 into r232;
    add r190 r228 into r233;
    ternary r229 r233 r190 into r234;
    not r205 into r235;
    get.or_use guaranteed_usd[r26[4u32]] 0u128 into r236;
    add r232 r236 into r237;
    ternary r235 r237 r232 into r238;
    get.or_use reserve_amounts[r26[4u32]] 0u128 into r239;
    not r205 into r240;
    sub.w r204 r239 into r241;
    mul r241 r203 into r242;
    pow 10u128 6u8 into r243;
    div r242 r243 into r244;
    add r238 r244 into r245;
    ternary r240 r245 r238 into r246;
    gt r234 r246 into r247;
    sub r246 r234 into r248;
    ternary r247 0u128 r248 into r249;
    gt r24.deduction r249 into r250;
    sub r249 r24.deduction into r251;
    ternary r250 0u128 r251 into r252;
    pow 10u128 6u8 into r253;
    mul r252 r253 into r254;
    pow 10u128 6u8 into r255;
    div r254 r255 into r256;
    get.or_use last_funding_blocks[r1] 0u32 into r257;
    div block.height 5760u32 into r258;
    mul r258 5760u32 into r259;
    is.eq r257 0u32 into r260;
    is.neq r257 0u32 into r261;
    add r257 5760u32 into r262;
    gt r262 block.height into r263;
    and r261 r263 into r264;
    ternary r264 r257 r259 into r265;
    ternary r260 r259 r265 into r266;
    get.or_use pool_amounts[r1] 0u128 into r267;
    sub block.height r257 into r268;
    div r268 5760u32 into r269;
    contains funding_rate_config[true] into r270;
    assert.eq r270 true;
    get funding_rate_config[true] into r271;
    get stable_tokens[r1] into r272;
    ternary r272 r271.stable_funding_rate_factor r271.funding_rate_factor into r273;
    is.eq r267 0u128 into r274;
    add r257 5760u32 into r275;
    gt r275 block.height into r276;
    or r274 r276 into r277;
    ternary r277 1u128 r267 into r278;
    is.eq r267 0u128 into r279;
    add r257 5760u32 into r280;
    gt r280 block.height into r281;
    or r279 r281 into r282;
    get.or_use reserve_amounts[r1] 0u128 into r283;
    mul r273 r283 into r284;
    cast r269 into r285 as u128;
    mul r284 r285 into r286;
    div.w r286 r278 into r287;
    ternary r282 0u128 r287 into r288;
    get.or_use cumulative_funding_rates[r1] 0u128 into r289;
    add r289 r288 into r290;
    set r290 into cumulative_funding_rates[r1];
    set r266 into last_funding_blocks[r1];
    get oracle_perps_v1.aleo/min_price[r1] into r291;
    mul r2 r291 into r292;
    pow 10u128 6u8 into r293;
    div r292 r293 into r294;
    gt r294 0u128 into r295;
    assert.eq r295 true;
    get.or_use usda_amounts[r1] 0u128 into r296;
    get tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field] into r297;
    contains total_token_weights[true] into r298;
    assert.eq r298 true;
    get total_token_weights[true] into r299;
    is.eq r299 0u128 into r300;
    ternary r300 1u128 r299 into r301;
    get.or_use token_weights[r1] 0u128 into r302;
    mul r302 r297.total_supply into r303;
    div r303 r301 into r304;
    add r296 r294 into r305;
    gt r294 r296 into r306;
    sub.w r296 r294 into r307;
    ternary r306 0u128 r307 into r308;
    ternary true r305 r308 into r309;
    gt r296 r304 into r310;
    sub.w r296 r304 into r311;
    sub.w r304 r296 into r312;
    ternary r310 r311 r312 into r313;
    gt r309 r304 into r314;
    sub.w r309 r304 into r315;
    sub.w r304 r309 into r316;
    ternary r314 r315 r316 into r317;
    is.neq r304 0u128 into r318;
    lt r317 r313 into r319;
    and r318 r319 into r320;
    ternary r320 r304 1u128 into r321;
    lt r317 r313 into r322;
    is.neq r304 0u128 into r323;
    and r322 r323 into r324;
    mul 50u128 r313 into r325;
    div r325 r321 into r326;
    ternary r324 r326 0u128 into r327;
    lt r317 r313 into r328;
    lte r327 30u128 into r329;
    and r328 r329 into r330;
    sub.w 30u128 r327 into r331;
    ternary r330 r331 0u128 into r332;
    gt r317 r313 into r333;
    add r313 r317 into r334;
    div r334 2u128 into r335;
    ternary r333 r335 0u128 into r336;
    gt r336 r304 into r337;
    ternary r337 r304 r336 into r338;
    is.eq r304 0u128 into r339;
    ternary r339 2u128 r304 into r340;
    not false into r341;
    is.eq r304 0u128 into r342;
    or r341 r342 into r343;
    lt r317 r313 into r344;
    mul 50u128 r338 into r345;
    div r345 r340 into r346;
    add 30u128 r346 into r347;
    ternary r344 r332 r347 into r348;
    ternary r343 30u128 r348 into r349;
    sub 10000u128 r349 into r350;
    mul r2 r350 into r351;
    div r351 10000u128 into r352;
    sub r2 r352 into r353;
    get.or_use fee_reserves[r1] 0u128 into r354;
    add r354 r353 into r355;
    set r355 into fee_reserves[r1];
    mul r352 r291 into r356;
    pow 10u128 6u8 into r357;
    div r356 r357 into r358;
    get.or_use usda_amounts[r1] 0u128 into r359;
    add r359 r358 into r360;
    set r360 into usda_amounts[r1];
    get.or_use max_usda_amounts[r1] 0u128 into r361;
    gt r361 0u128 into r362;
    get usda_amounts[r1] into r363;
    lte r363 r361 into r364;
    ternary r362 r364 true into r365;
    assert.eq r365 true;
    get.or_use pool_amounts[r1] 0u128 into r366;
    add r366 r352 into r367;
    set r367 into pool_amounts[r1];
    gte r358 r3 into r368;
    assert.eq r368 true;
    add r297.total_supply r358 into r369;
    cast r297.name r297.symbol r297.decimals r369 r297.admin into r370 as TokenInfo;
    set r370 into tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field];
    cast 5831693778411205416925069027464809696308596398099265250571387651489705378046field aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r371 as AccountKey;
    hash.bhp256 r371 into r372 as field;
    get.or_use account[r372] 0u128 into r373;
    add r373 r358 into r374;
    set r374 into account[r372];
    get tokens[6769995254802454894577392401849975163810476770055238272962759031196088045850field] into r375;
    is.eq r256 0u128 into r376;
    ternary r376 1u128 r256 into r377;
    is.eq r256 0u128 into r378;
    is.eq r375.total_supply 0u128 into r379;
    or r378 r379 into r380;
    mul r358 r375.total_supply into r381;
    div r381 r377 into r382;
    ternary r380 r358 r382 into r383;
    gte r383 r4 into r384;
    assert.eq r384 true;
    add r375.total_supply r383 into r385;
    cast r375.name r375.symbol r375.decimals r385 r375.admin into r386 as TokenInfo;
    set r386 into tokens[6769995254802454894577392401849975163810476770055238272962759031196088045850field];
    cast 6769995254802454894577392401849975163810476770055238272962759031196088045850field r0 into r387 as AccountKey;
    hash.bhp256 r387 into r388 as field;
    get.or_use account[r388] 0u128 into r389;
    add r389 r383 into r390;
    set r390 into account[r388];
    set block.height into last_added_at[r0];


function remove_liquidity:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as u128.public;
    input r3 as address.public;
    gt r1 0u128 into r4;
    assert.eq r4 true;
    async remove_liquidity self.caller r0 r1 r2 r3 into r5;
    output r5 as pool_perps_v1.aleo/remove_liquidity.future;

finalize remove_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    contains tokens[r1] into r5;
    assert.eq r5 true;
    contains whitelist_token_ids[true] into r6;
    assert.eq r6 true;
    get whitelist_token_ids[true] into r7;
    is.eq r7[0u32] r1 into r8;
    is.eq r7[1u32] r1 into r9;
    or r8 r9 into r10;
    is.eq r7[2u32] r1 into r11;
    or r10 r11 into r12;
    is.eq r7[3u32] r1 into r13;
    or r12 r13 into r14;
    is.eq r7[4u32] r1 into r15;
    or r14 r15 into r16;
    assert.eq r16 true;
    contains cooldown_duration[true] into r17;
    assert.eq r17 true;
    get last_added_at[r0] into r18;
    get cooldown_duration[true] into r19;
    add r18 r19 into r20;
    lte r20 block.height into r21;
    assert.eq r21 true;
    contains aum_config[true] into r22;
    assert.eq r22 true;
    get aum_config[true] into r23;
    contains whitelist_token_ids[true] into r24;
    assert.eq r24 true;
    get whitelist_token_ids[true] into r25;
    get oracle_perps_v1.aleo/min_price[r25[0u32]] into r26;
    get.or_use pool_amounts[r25[0u32]] 0u128 into r27;
    get stable_tokens[r25[0u32]] into r28;
    mul r27 r26 into r29;
    pow 10u128 6u8 into r30;
    div r29 r30 into r31;
    add r23.addition r31 into r32;
    ternary r28 r32 r23.addition into r33;
    not r28 into r34;
    get.or_use global_short_sizes[r25[0u32]] 0u128 into r35;
    ternary r34 r35 0u128 into r36;
    not r28 into r37;
    gt r36 0u128 into r38;
    and r37 r38 into r39;
    get.or_use global_short_average_prices[r25[0u32]] 0u128 into r40;
    ternary r39 r40 0u128 into r41;
    gt r41 r26 into r42;
    sub.w r41 r26 into r43;
    sub.w r26 r41 into r44;
    ternary r42 r43 r44 into r45;
    is.eq r41 0u128 into r46;
    ternary r46 1u128 r41 into r47;
    is.neq r41 0u128 into r48;
    mul r36 r45 into r49;
    div.w r49 r47 into r50;
    ternary r48 r50 0u128 into r51;
    gt r41 r26 into r52;
    not r52 into r53;
    add r33 r51 into r54;
    ternary r53 r54 r33 into r55;
    add 0u128 r51 into r56;
    ternary r52 r56 0u128 into r57;
    not r28 into r58;
    get.or_use guaranteed_usd[r25[0u32]] 0u128 into r59;
    add r55 r59 into r60;
    ternary r58 r60 r55 into r61;
    get.or_use reserve_amounts[r25[0u32]] 0u128 into r62;
    not r28 into r63;
    sub.w r27 r62 into r64;
    mul r64 r26 into r65;
    pow 10u128 6u8 into r66;
    div r65 r66 into r67;
    add r61 r67 into r68;
    ternary r63 r68 r61 into r69;
    get oracle_perps_v1.aleo/min_price[r25[1u32]] into r70;
    get.or_use pool_amounts[r25[1u32]] 0u128 into r71;
    get stable_tokens[r25[1u32]] into r72;
    mul r71 r70 into r73;
    pow 10u128 6u8 into r74;
    div r73 r74 into r75;
    add r69 r75 into r76;
    ternary r72 r76 r69 into r77;
    not r72 into r78;
    get.or_use global_short_sizes[r25[1u32]] 0u128 into r79;
    ternary r78 r79 0u128 into r80;
    not r72 into r81;
    gt r80 0u128 into r82;
    and r81 r82 into r83;
    get.or_use global_short_average_prices[r25[1u32]] 0u128 into r84;
    ternary r83 r84 0u128 into r85;
    gt r85 r70 into r86;
    sub.w r85 r70 into r87;
    sub.w r70 r85 into r88;
    ternary r86 r87 r88 into r89;
    is.eq r85 0u128 into r90;
    ternary r90 1u128 r85 into r91;
    is.neq r85 0u128 into r92;
    mul r80 r89 into r93;
    div.w r93 r91 into r94;
    ternary r92 r94 0u128 into r95;
    gt r85 r70 into r96;
    not r96 into r97;
    add r77 r95 into r98;
    ternary r97 r98 r77 into r99;
    add r57 r95 into r100;
    ternary r96 r100 r57 into r101;
    not r72 into r102;
    get.or_use guaranteed_usd[r25[1u32]] 0u128 into r103;
    add r99 r103 into r104;
    ternary r102 r104 r99 into r105;
    get.or_use reserve_amounts[r25[1u32]] 0u128 into r106;
    not r72 into r107;
    sub.w r71 r106 into r108;
    mul r108 r70 into r109;
    pow 10u128 6u8 into r110;
    div r109 r110 into r111;
    add r105 r111 into r112;
    ternary r107 r112 r105 into r113;
    get oracle_perps_v1.aleo/min_price[r25[2u32]] into r114;
    get.or_use pool_amounts[r25[2u32]] 0u128 into r115;
    get stable_tokens[r25[2u32]] into r116;
    mul r115 r114 into r117;
    pow 10u128 6u8 into r118;
    div r117 r118 into r119;
    add r113 r119 into r120;
    ternary r116 r120 r113 into r121;
    not r116 into r122;
    get.or_use global_short_sizes[r25[2u32]] 0u128 into r123;
    ternary r122 r123 0u128 into r124;
    not r116 into r125;
    gt r124 0u128 into r126;
    and r125 r126 into r127;
    get.or_use global_short_average_prices[r25[2u32]] 0u128 into r128;
    ternary r127 r128 0u128 into r129;
    gt r129 r114 into r130;
    sub.w r129 r114 into r131;
    sub.w r114 r129 into r132;
    ternary r130 r131 r132 into r133;
    is.eq r129 0u128 into r134;
    ternary r134 1u128 r129 into r135;
    is.neq r129 0u128 into r136;
    mul r124 r133 into r137;
    div.w r137 r135 into r138;
    ternary r136 r138 0u128 into r139;
    gt r129 r114 into r140;
    not r140 into r141;
    add r121 r139 into r142;
    ternary r141 r142 r121 into r143;
    add r101 r139 into r144;
    ternary r140 r144 r101 into r145;
    not r116 into r146;
    get.or_use guaranteed_usd[r25[2u32]] 0u128 into r147;
    add r143 r147 into r148;
    ternary r146 r148 r143 into r149;
    get.or_use reserve_amounts[r25[2u32]] 0u128 into r150;
    not r116 into r151;
    sub.w r115 r150 into r152;
    mul r152 r114 into r153;
    pow 10u128 6u8 into r154;
    div r153 r154 into r155;
    add r149 r155 into r156;
    ternary r151 r156 r149 into r157;
    get oracle_perps_v1.aleo/min_price[r25[3u32]] into r158;
    get.or_use pool_amounts[r25[3u32]] 0u128 into r159;
    get stable_tokens[r25[3u32]] into r160;
    mul r159 r158 into r161;
    pow 10u128 6u8 into r162;
    div r161 r162 into r163;
    add r157 r163 into r164;
    ternary r160 r164 r157 into r165;
    not r160 into r166;
    get.or_use global_short_sizes[r25[3u32]] 0u128 into r167;
    ternary r166 r167 0u128 into r168;
    not r160 into r169;
    gt r168 0u128 into r170;
    and r169 r170 into r171;
    get.or_use global_short_average_prices[r25[3u32]] 0u128 into r172;
    ternary r171 r172 0u128 into r173;
    gt r173 r158 into r174;
    sub.w r173 r158 into r175;
    sub.w r158 r173 into r176;
    ternary r174 r175 r176 into r177;
    is.eq r173 0u128 into r178;
    ternary r178 1u128 r173 into r179;
    is.neq r173 0u128 into r180;
    mul r168 r177 into r181;
    div.w r181 r179 into r182;
    ternary r180 r182 0u128 into r183;
    gt r173 r158 into r184;
    not r184 into r185;
    add r165 r183 into r186;
    ternary r185 r186 r165 into r187;
    add r145 r183 into r188;
    ternary r184 r188 r145 into r189;
    not r160 into r190;
    get.or_use guaranteed_usd[r25[3u32]] 0u128 into r191;
    add r187 r191 into r192;
    ternary r190 r192 r187 into r193;
    get.or_use reserve_amounts[r25[3u32]] 0u128 into r194;
    not r160 into r195;
    sub.w r159 r194 into r196;
    mul r196 r158 into r197;
    pow 10u128 6u8 into r198;
    div r197 r198 into r199;
    add r193 r199 into r200;
    ternary r195 r200 r193 into r201;
    get oracle_perps_v1.aleo/min_price[r25[4u32]] into r202;
    get.or_use pool_amounts[r25[4u32]] 0u128 into r203;
    get stable_tokens[r25[4u32]] into r204;
    mul r203 r202 into r205;
    pow 10u128 6u8 into r206;
    div r205 r206 into r207;
    add r201 r207 into r208;
    ternary r204 r208 r201 into r209;
    not r204 into r210;
    get.or_use global_short_sizes[r25[4u32]] 0u128 into r211;
    ternary r210 r211 0u128 into r212;
    not r204 into r213;
    gt r212 0u128 into r214;
    and r213 r214 into r215;
    get.or_use global_short_average_prices[r25[4u32]] 0u128 into r216;
    ternary r215 r216 0u128 into r217;
    gt r217 r202 into r218;
    sub.w r217 r202 into r219;
    sub.w r202 r217 into r220;
    ternary r218 r219 r220 into r221;
    is.eq r217 0u128 into r222;
    ternary r222 1u128 r217 into r223;
    is.neq r217 0u128 into r224;
    mul r212 r221 into r225;
    div.w r225 r223 into r226;
    ternary r224 r226 0u128 into r227;
    gt r217 r202 into r228;
    not r228 into r229;
    add r209 r227 into r230;
    ternary r229 r230 r209 into r231;
    add r189 r227 into r232;
    ternary r228 r232 r189 into r233;
    not r204 into r234;
    get.or_use guaranteed_usd[r25[4u32]] 0u128 into r235;
    add r231 r235 into r236;
    ternary r234 r236 r231 into r237;
    get.or_use reserve_amounts[r25[4u32]] 0u128 into r238;
    not r204 into r239;
    sub.w r203 r238 into r240;
    mul r240 r202 into r241;
    pow 10u128 6u8 into r242;
    div r241 r242 into r243;
    add r237 r243 into r244;
    ternary r239 r244 r237 into r245;
    gt r233 r245 into r246;
    sub r245 r233 into r247;
    ternary r246 0u128 r247 into r248;
    gt r23.deduction r248 into r249;
    sub r248 r23.deduction into r250;
    ternary r249 0u128 r250 into r251;
    pow 10u128 6u8 into r252;
    mul r251 r252 into r253;
    pow 10u128 6u8 into r254;
    div r253 r254 into r255;
    get tokens[6769995254802454894577392401849975163810476770055238272962759031196088045850field] into r256;
    mul r2 r255 into r257;
    div r257 r256.total_supply into r258;
    assert.eq r256.admin aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y;
    sub r256.total_supply r2 into r259;
    cast r256.name r256.symbol r256.decimals r259 r256.admin into r260 as TokenInfo;
    set r260 into tokens[6769995254802454894577392401849975163810476770055238272962759031196088045850field];
    cast 6769995254802454894577392401849975163810476770055238272962759031196088045850field r0 into r261 as AccountKey;
    hash.bhp256 r261 into r262 as field;
    get account[r262] into r263;
    gte r263 r2 into r264;
    assert.eq r264 true;
    get account[r262] into r265;
    sub r265 r2 into r266;
    set r266 into account[r262];
    get.or_use last_funding_blocks[r1] 0u32 into r267;
    div block.height 5760u32 into r268;
    mul r268 5760u32 into r269;
    is.eq r267 0u32 into r270;
    is.neq r267 0u32 into r271;
    add r267 5760u32 into r272;
    gt r272 block.height into r273;
    and r271 r273 into r274;
    ternary r274 r267 r269 into r275;
    ternary r270 r269 r275 into r276;
    get.or_use pool_amounts[r1] 0u128 into r277;
    sub block.height r267 into r278;
    div r278 5760u32 into r279;
    contains funding_rate_config[true] into r280;
    assert.eq r280 true;
    get funding_rate_config[true] into r281;
    get stable_tokens[r1] into r282;
    ternary r282 r281.stable_funding_rate_factor r281.funding_rate_factor into r283;
    is.eq r277 0u128 into r284;
    add r267 5760u32 into r285;
    gt r285 block.height into r286;
    or r284 r286 into r287;
    ternary r287 1u128 r277 into r288;
    is.eq r277 0u128 into r289;
    add r267 5760u32 into r290;
    gt r290 block.height into r291;
    or r289 r291 into r292;
    get.or_use reserve_amounts[r1] 0u128 into r293;
    mul r283 r293 into r294;
    cast r279 into r295 as u128;
    mul r294 r295 into r296;
    div.w r296 r288 into r297;
    ternary r292 0u128 r297 into r298;
    get.or_use cumulative_funding_rates[r1] 0u128 into r299;
    add r299 r298 into r300;
    set r300 into cumulative_funding_rates[r1];
    set r276 into last_funding_blocks[r1];
    get oracle_perps_v1.aleo/max_price[r1] into r301;
    pow 10u128 6u8 into r302;
    mul r258 r302 into r303;
    div r303 r301 into r304;
    gt r304 0u128 into r305;
    assert.eq r305 true;
    get.or_use usda_amounts[r1] 0u128 into r306;
    lte r258 r306 into r307;
    sub.w r306 r258 into r308;
    ternary r307 r308 0u128 into r309;
    set r309 into usda_amounts[r1];
    get pool_amounts[r1] into r310;
    gte r310 r304 into r311;
    assert.eq r311 true;
    get pool_amounts[r1] into r312;
    sub r312 r304 into r313;
    set r313 into pool_amounts[r1];
    get pool_amounts[r1] into r314;
    get.or_use reserve_amounts[r1] 0u128 into r315;
    gte r314 r315 into r316;
    assert.eq r316 true;
    cast 5831693778411205416925069027464809696308596398099265250571387651489705378046field aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r317 as AccountKey;
    hash.bhp256 r317 into r318 as field;
    get.or_use account[r318] 0u128 into r319;
    gt r319 r258 into r320;
    ternary r320 r258 r319 into r321;
    get tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field] into r322;
    assert.eq r322.admin aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y;
    sub r322.total_supply r321 into r323;
    cast r322.name r322.symbol r322.decimals r323 r322.admin into r324 as TokenInfo;
    set r324 into tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field];
    sub r319 r321 into r325;
    set r325 into account[r318];
    get.or_use usda_amounts[r1] 0u128 into r326;
    contains total_token_weights[true] into r327;
    assert.eq r327 true;
    get total_token_weights[true] into r328;
    is.eq r328 0u128 into r329;
    ternary r329 1u128 r328 into r330;
    get.or_use token_weights[r1] 0u128 into r331;
    mul r331 r322.total_supply into r332;
    div r332 r330 into r333;
    add r326 r258 into r334;
    gt r258 r326 into r335;
    sub.w r326 r258 into r336;
    ternary r335 0u128 r336 into r337;
    ternary false r334 r337 into r338;
    gt r326 r333 into r339;
    sub.w r326 r333 into r340;
    sub.w r333 r326 into r341;
    ternary r339 r340 r341 into r342;
    gt r338 r333 into r343;
    sub.w r338 r333 into r344;
    sub.w r333 r338 into r345;
    ternary r343 r344 r345 into r346;
    is.neq r333 0u128 into r347;
    lt r346 r342 into r348;
    and r347 r348 into r349;
    ternary r349 r333 1u128 into r350;
    lt r346 r342 into r351;
    is.neq r333 0u128 into r352;
    and r351 r352 into r353;
    mul 50u128 r342 into r354;
    div r354 r350 into r355;
    ternary r353 r355 0u128 into r356;
    lt r346 r342 into r357;
    lte r356 30u128 into r358;
    and r357 r358 into r359;
    sub.w 30u128 r356 into r360;
    ternary r359 r360 0u128 into r361;
    gt r346 r342 into r362;
    add r342 r346 into r363;
    div r363 2u128 into r364;
    ternary r362 r364 0u128 into r365;
    gt r365 r333 into r366;
    ternary r366 r333 r365 into r367;
    is.eq r333 0u128 into r368;
    ternary r368 2u128 r333 into r369;
    not false into r370;
    is.eq r333 0u128 into r371;
    or r370 r371 into r372;
    lt r346 r342 into r373;
    mul 50u128 r367 into r374;
    div r374 r369 into r375;
    add 30u128 r375 into r376;
    ternary r373 r361 r376 into r377;
    ternary r372 30u128 r377 into r378;
    sub 10000u128 r378 into r379;
    mul r304 r379 into r380;
    div r380 10000u128 into r381;
    sub r304 r381 into r382;
    get.or_use fee_reserves[r1] 0u128 into r383;
    add r383 r382 into r384;
    set r384 into fee_reserves[r1];
    gte r381 r3 into r385;
    assert.eq r385 true;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r386 as AccountKey;
    hash.bhp256 r386 into r387 as field;
    get account[r387] into r388;
    sub r388 r381 into r389;
    set r389 into account[r387];
    cast r1 r4 into r390 as AccountKey;
    hash.bhp256 r390 into r391 as field;
    get.or_use account[r391] 0u128 into r392;
    add r392 r381 into r393;
    set r393 into account[r391];


function direct_pool_deposit:
    input r0 as field.public;
    input r1 as u128.public;
    gt r1 0u128 into r2;
    assert.eq r2 true;
    cast r0 self.caller into r3 as AccountKey;
    hash.bhp256 r3 into r4 as field;
    cast r0 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r5 as AccountKey;
    hash.bhp256 r5 into r6 as field;
    async direct_pool_deposit r4 r6 r0 r1 into r7;
    output r7 as pool_perps_v1.aleo/direct_pool_deposit.future;

finalize direct_pool_deposit:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    contains whitelist_token_ids[true] into r4;
    assert.eq r4 true;
    get whitelist_token_ids[true] into r5;
    is.eq r5[0u32] r2 into r6;
    is.eq r5[1u32] r2 into r7;
    or r6 r7 into r8;
    is.eq r5[2u32] r2 into r9;
    or r8 r9 into r10;
    is.eq r5[3u32] r2 into r11;
    or r10 r11 into r12;
    is.eq r5[4u32] r2 into r13;
    or r12 r13 into r14;
    assert.eq r14 true;
    contains tokens[r2] into r15;
    assert.eq r15 true;
    get account[r0] into r16;
    sub r16 r3 into r17;
    set r17 into account[r0];
    get.or_use account[r1] 0u128 into r18;
    add r18 r3 into r19;
    set r19 into account[r1];
    get.or_use pool_amounts[r2] 0u128 into r20;
    add r20 r3 into r21;
    set r21 into pool_amounts[r2];
    get pool_amounts[r2] into r22;
    get account[r1] into r23;
    lte r22 r23 into r24;
    assert.eq r24 true;
















function increase_position:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as boolean.public;
    input r5 as u128.public;
    gt r1 0u128 into r6;
    assert.eq r6 true;
    async increase_position self.caller r0 r1 r2 r3 r4 r5 into r7;
    output r7 as pool_perps_v1.aleo/increase_position.future;

finalize increase_position:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as field.public;
    input r4 as u128.public;
    input r5 as boolean.public;
    input r6 as u128.public;
    contains whitelist_token_ids[true] into r7;
    assert.eq r7 true;
    get whitelist_token_ids[true] into r8;
    is.eq r8[0u32] r1 into r9;
    is.eq r8[1u32] r1 into r10;
    or r9 r10 into r11;
    is.eq r8[2u32] r1 into r12;
    or r11 r12 into r13;
    is.eq r8[3u32] r1 into r14;
    or r13 r14 into r15;
    is.eq r8[4u32] r1 into r16;
    or r15 r16 into r17;
    assert.eq r17 true;
    get whitelist_token_ids[true] into r18;
    is.eq r18[0u32] r3 into r19;
    is.eq r18[1u32] r3 into r20;
    or r19 r20 into r21;
    is.eq r18[2u32] r3 into r22;
    or r21 r22 into r23;
    is.eq r18[3u32] r3 into r24;
    or r23 r24 into r25;
    is.eq r18[4u32] r3 into r26;
    or r25 r26 into r27;
    assert.eq r27 true;
    contains tokens[r1] into r28;
    assert.eq r28 true;
    contains tokens[r3] into r29;
    assert.eq r29 true;
    is.eq r1 r3 into r30;
    get stable_tokens[r1] into r31;
    not r31 into r32;
    and r30 r32 into r33;
    get stable_tokens[r1] into r34;
    get stable_tokens[r3] into r35;
    not r35 into r36;
    and r34 r36 into r37;
    ternary r5 r33 r37 into r38;
    assert.eq r38 true;
    get oracle_perps_v1.aleo/max_price[r3] into r39;
    get oracle_perps_v1.aleo/min_price[r3] into r40;
    lte r39 r6 into r41;
    gte r40 r6 into r42;
    ternary r5 r41 r42 into r43;
    assert.eq r43 true;
    cast r1 r0 into r44 as AccountKey;
    hash.bhp256 r44 into r45 as field;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r46 as AccountKey;
    hash.bhp256 r46 into r47 as field;
    get account[r45] into r48;
    gte r48 r2 into r49;
    assert.eq r49 true;
    get account[r45] into r50;
    sub r50 r2 into r51;
    set r51 into account[r45];
    get.or_use account[r47] 0u128 into r52;
    add r52 r2 into r53;
    set r53 into account[r47];
    get.or_use last_funding_blocks[r1] 0u32 into r54;
    div block.height 5760u32 into r55;
    mul r55 5760u32 into r56;
    is.eq r54 0u32 into r57;
    is.neq r54 0u32 into r58;
    add r54 5760u32 into r59;
    gt r59 block.height into r60;
    and r58 r60 into r61;
    ternary r61 r54 r56 into r62;
    ternary r57 r56 r62 into r63;
    get.or_use pool_amounts[r1] 0u128 into r64;
    sub block.height r54 into r65;
    div r65 5760u32 into r66;
    contains funding_rate_config[true] into r67;
    assert.eq r67 true;
    get funding_rate_config[true] into r68;
    get stable_tokens[r1] into r69;
    ternary r69 r68.stable_funding_rate_factor r68.funding_rate_factor into r70;
    is.eq r64 0u128 into r71;
    add r54 5760u32 into r72;
    gt r72 block.height into r73;
    or r71 r73 into r74;
    ternary r74 1u128 r64 into r75;
    is.eq r64 0u128 into r76;
    add r54 5760u32 into r77;
    gt r77 block.height into r78;
    or r76 r78 into r79;
    get.or_use reserve_amounts[r1] 0u128 into r80;
    mul r70 r80 into r81;
    cast r66 into r82 as u128;
    mul r81 r82 into r83;
    div.w r83 r75 into r84;
    ternary r79 0u128 r84 into r85;
    get.or_use cumulative_funding_rates[r1] 0u128 into r86;
    add r86 r85 into r87;
    set r87 into cumulative_funding_rates[r1];
    set r63 into last_funding_blocks[r1];
    cast r0 r1 r3 r5 into r88 as PositionKey;
    hash.bhp256 r88 into r89 as field;
    cast 0u128 0u128 0u128 0u128 0u128 0i128 0u32 into r90 as Position;
    get.or_use positions[r89] r90 into r91;
    ternary r5 r39 r40 into r92;
    ternary r5 r40 r39 into r93;
    contains min_profit_block[true] into r94;
    assert.eq r94 true;
    get min_profit_block[true] into r95;
    add r91.last_increased_block r95 into r96;
    gt block.height r96 into r97;
    get.or_use min_profit_basis_points[r3] 0u32 into r98;
    ternary r97 0u32 r98 into r99;
    gt r91.average_price r93 into r100;
    sub.w r91.average_price r93 into r101;
    sub.w r93 r91.average_price into r102;
    ternary r100 r101 r102 into r103;
    is.eq r91.average_price 0u128 into r104;
    ternary r104 1u128 r91.average_price into r105;
    is.eq r91.average_price 0u128 into r106;
    mul r91.size r103 into r107;
    div.w r107 r105 into r108;
    ternary r106 0u128 r108 into r109;
    gt r93 r91.average_price into r110;
    gt r91.average_price r93 into r111;
    ternary r5 r110 r111 into r112;
    mul r109 10000u128 into r113;
    cast r99 into r114 as u128;
    mul r91.size r114 into r115;
    lte r113 r115 into r116;
    and r112 r116 into r117;
    ternary r117 0u128 r109 into r118;
    add r91.size r4 into r119;
    add r119 r118 into r120;
    sub.w r119 r118 into r121;
    ternary r112 r120 r121 into r122;
    sub.w r119 r118 into r123;
    add r119 r118 into r124;
    ternary r112 r123 r124 into r125;
    ternary r5 r122 r125 into r126;
    mul r92 r119 into r127;
    div r127 r126 into r128;
    is.eq r91.size 0u128 into r129;
    gt r91.size 0u128 into r130;
    gt r4 0u128 into r131;
    and r130 r131 into r132;
    ternary r132 r128 r91.average_price into r133;
    ternary r129 r92 r133 into r134;
    get.or_use cumulative_funding_rates[r1] 0u128 into r135;
    is.eq r4 0u128 into r136;
    sub 10000u128 10u128 into r137;
    mul r4 r137 into r138;
    div r138 10000u128 into r139;
    sub r4 r139 into r140;
    ternary r136 0u128 r140 into r141;
    sub r135 r91.entry_funding_rate into r142;
    is.eq r91.size 0u128 into r143;
    is.eq r142 0u128 into r144;
    or r143 r144 into r145;
    mul r91.size r142 into r146;
    div r146 1000000u128 into r147;
    ternary r145 0u128 r147 into r148;
    add r141 r148 into r149;
    get oracle_perps_v1.aleo/max_price[r1] into r150;
    pow 10u128 6u8 into r151;
    mul r149 r151 into r152;
    div r152 r150 into r153;
    get.or_use fee_reserves[r1] 0u128 into r154;
    add r154 r153 into r155;
    set r155 into fee_reserves[r1];
    get oracle_perps_v1.aleo/min_price[r1] into r156;
    mul r2 r156 into r157;
    pow 10u128 6u8 into r158;
    div r157 r158 into r159;
    add r91.collateral r159 into r160;
    sub r160 r149 into r161;
    gte r161 0u128 into r162;
    assert.eq r162 true;
    add r91.size r4 into r163;
    gte r163 r161 into r164;
    assert.eq r164 true;
    pow 10u128 6u8 into r165;
    mul r4 r165 into r166;
    div r166 r156 into r167;
    add r91.reserve_amount r167 into r168;
    cast r163 r161 r134 r135 r168 r91.realised_pnl block.height into r169 as Position;
    set r169 into positions[r89];
    get positions[r89] into r170;
    gt r170.average_price r93 into r171;
    sub.w r170.average_price r93 into r172;
    sub.w r93 r170.average_price into r173;
    ternary r171 r172 r173 into r174;
    is.eq r170.average_price 0u128 into r175;
    ternary r175 1u128 r170.average_price into r176;
    is.eq r170.average_price 0u128 into r177;
    mul r170.size r174 into r178;
    div.w r178 r176 into r179;
    ternary r177 0u128 r179 into r180;
    gt r93 r170.average_price into r181;
    gt r170.average_price r93 into r182;
    ternary r5 r181 r182 into r183;
    mul r180 10000u128 into r184;
    cast r99 into r185 as u128;
    mul r170.size r185 into r186;
    lte r184 r186 into r187;
    and r183 r187 into r188;
    ternary r188 0u128 r180 into r189;
    is.eq r170.size 0u128 into r190;
    sub 10000u128 10u128 into r191;
    mul r170.size r191 into r192;
    div r192 10000u128 into r193;
    sub r170.size r193 into r194;
    ternary r190 0u128 r194 into r195;
    sub r135 r170.entry_funding_rate into r196;
    is.eq r170.size 0u128 into r197;
    is.eq r196 0u128 into r198;
    or r197 r198 into r199;
    mul r170.size r196 into r200;
    div r200 1000000u128 into r201;
    ternary r199 0u128 r201 into r202;
    add r195 r202 into r203;
    not r183 into r204;
    gte r161 r189 into r205;
    and r204 r205 into r206;
    sub.w r161 r189 into r207;
    ternary r206 r207 0u128 into r208;
    ternary r183 r161 r208 into r209;
    is.neq r209 0u128 into r210;
    lt r209 r203 into r211;
    and r210 r211 into r212;
    is.neq r209 0u128 into r213;
    gte r209 r203 into r214;
    and r213 r214 into r215;
    add r203 5000000u128 into r216;
    lt r209 r216 into r217;
    and r215 r217 into r218;
    is.neq r209 0u128 into r219;
    add r203 5000000u128 into r220;
    gte r209 r220 into r221;
    and r219 r221 into r222;
    mul r209 500000u128 into r223;
    mul r163 10000u128 into r224;
    lt r223 r224 into r225;
    and r222 r225 into r226;
    is.eq r209 0u128 into r227;
    or r227 r212 into r228;
    or r228 r218 into r229;
    ternary r226 2u8 0u8 into r230;
    ternary r229 1u8 r230 into r231;
    ternary r212 r209 r203 into r232;
    is.eq r231 0u8 into r233;
    assert.eq r233 true;
    get.or_use reserve_amounts[r1] 0u128 into r234;
    add r234 r167 into r235;
    set r235 into reserve_amounts[r1];
    get reserve_amounts[r1] into r236;
    get pool_amounts[r1] into r237;
    lte r236 r237 into r238;
    assert.eq r238 true;
    get.or_use guaranteed_usd[r1] 0u128 into r239;
    add r239 r4 into r240;
    add r240 r149 into r241;
    sub.w r241 r159 into r242;
    ternary r5 r242 r239 into r243;
    get.or_use pool_amounts[r1] 0u128 into r244;
    add r244 r2 into r245;
    sub.w r245 r153 into r246;
    get.or_use pool_amounts[r1] 0u128 into r247;
    ternary r5 r246 r247 into r248;
    set r243 into guaranteed_usd[r1];
    set r248 into pool_amounts[r1];
    get.or_use global_short_sizes[r3] 0u128 into r249;
    get.or_use global_short_average_prices[r3] 0u128 into r250;
    not r5 into r251;
    is.neq r249 0u128 into r252;
    and r251 r252 into r253;
    gt r250 r92 into r254;
    sub.w r250 r92 into r255;
    sub.w r92 r250 into r256;
    ternary r254 r255 r256 into r257;
    is.eq r250 0u128 into r258;
    ternary r258 1u128 r250 into r259;
    is.eq r250 0u128 into r260;
    mul r249 r257 into r261;
    div r261 r259 into r262;
    ternary r260 0u128 r262 into r263;
    gt r250 r92 into r264;
    add r249 r4 into r265;
    sub r265 r263 into r266;
    add r265 r263 into r267;
    ternary r264 r266 r267 into r268;
    mul r92 r265 into r269;
    div r269 r268 into r270;
    ternary r253 r270 0u128 into r271;
    not r5 into r272;
    is.eq r249 0u128 into r273;
    and r272 r273 into r274;
    not r5 into r275;
    is.neq r249 0u128 into r276;
    and r275 r276 into r277;
    ternary r277 r271 r250 into r278;
    ternary r274 r92 r278 into r279;
    set r279 into global_short_average_prices[r3];
    add r249 r4 into r280;
    ternary r5 r249 r280 into r281;
    set r281 into global_short_sizes[r3];
    get.or_use max_global_short_sizes[r3] 0u128 into r282;
    is.neq r282 0u128 into r283;
    lte r281 r282 into r284;
    ternary r283 r284 true into r285;
    assert.eq r285 true;


function decrease_position:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as boolean.public;
    input r5 as address.public;
    input r6 as u128.public;
    async decrease_position self.caller r0 r1 r2 r3 r4 r5 r6 into r7;
    output r7 as pool_perps_v1.aleo/decrease_position.future;

finalize decrease_position:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as boolean.public;
    input r6 as address.public;
    input r7 as u128.public;
    contains tokens[r1] into r8;
    assert.eq r8 true;
    contains tokens[r2] into r9;
    assert.eq r9 true;
    contains whitelist_token_ids[true] into r10;
    assert.eq r10 true;
    get whitelist_token_ids[true] into r11;
    is.eq r11[0u32] r1 into r12;
    is.eq r11[1u32] r1 into r13;
    or r12 r13 into r14;
    is.eq r11[2u32] r1 into r15;
    or r14 r15 into r16;
    is.eq r11[3u32] r1 into r17;
    or r16 r17 into r18;
    is.eq r11[4u32] r1 into r19;
    or r18 r19 into r20;
    assert.eq r20 true;
    get whitelist_token_ids[true] into r21;
    is.eq r21[0u32] r2 into r22;
    is.eq r21[1u32] r2 into r23;
    or r22 r23 into r24;
    is.eq r21[2u32] r2 into r25;
    or r24 r25 into r26;
    is.eq r21[3u32] r2 into r27;
    or r26 r27 into r28;
    is.eq r21[4u32] r2 into r29;
    or r28 r29 into r30;
    assert.eq r30 true;
    get oracle_perps_v1.aleo/max_price[r2] into r31;
    get oracle_perps_v1.aleo/min_price[r2] into r32;
    gte r32 r7 into r33;
    lte r31 r7 into r34;
    ternary r5 r33 r34 into r35;
    assert.eq r35 true;
    get.or_use last_funding_blocks[r1] 0u32 into r36;
    div block.height 5760u32 into r37;
    mul r37 5760u32 into r38;
    is.eq r36 0u32 into r39;
    is.neq r36 0u32 into r40;
    add r36 5760u32 into r41;
    gt r41 block.height into r42;
    and r40 r42 into r43;
    ternary r43 r36 r38 into r44;
    ternary r39 r38 r44 into r45;
    get.or_use pool_amounts[r1] 0u128 into r46;
    sub block.height r36 into r47;
    div r47 5760u32 into r48;
    contains funding_rate_config[true] into r49;
    assert.eq r49 true;
    get funding_rate_config[true] into r50;
    get stable_tokens[r1] into r51;
    ternary r51 r50.stable_funding_rate_factor r50.funding_rate_factor into r52;
    is.eq r46 0u128 into r53;
    add r36 5760u32 into r54;
    gt r54 block.height into r55;
    or r53 r55 into r56;
    ternary r56 1u128 r46 into r57;
    is.eq r46 0u128 into r58;
    add r36 5760u32 into r59;
    gt r59 block.height into r60;
    or r58 r60 into r61;
    get.or_use reserve_amounts[r1] 0u128 into r62;
    mul r52 r62 into r63;
    cast r48 into r64 as u128;
    mul r63 r64 into r65;
    div.w r65 r57 into r66;
    ternary r61 0u128 r66 into r67;
    get.or_use cumulative_funding_rates[r1] 0u128 into r68;
    add r68 r67 into r69;
    set r69 into cumulative_funding_rates[r1];
    set r45 into last_funding_blocks[r1];
    cast r0 r1 r2 r5 into r70 as PositionKey;
    hash.bhp256 r70 into r71 as field;
    get positions[r71] into r72;
    gt r72.size 0u128 into r73;
    assert.eq r73 true;
    gte r72.size r4 into r74;
    assert.eq r74 true;
    gte r72.collateral r3 into r75;
    assert.eq r75 true;
    mul r72.reserve_amount r4 into r76;
    div r76 r72.size into r77;
    is.eq r72.size r4 into r78;
    sub r72.reserve_amount r77 into r79;
    ternary r78 0u128 r79 into r80;
    get reserve_amounts[r1] into r81;
    sub r81 r77 into r82;
    set r82 into reserve_amounts[r1];
    get cumulative_funding_rates[r1] into r83;
    is.eq r4 0u128 into r84;
    sub 10000u128 10u128 into r85;
    mul r4 r85 into r86;
    div r86 10000u128 into r87;
    sub r4 r87 into r88;
    ternary r84 0u128 r88 into r89;
    sub r83 r72.entry_funding_rate into r90;
    is.eq r72.size 0u128 into r91;
    is.eq r90 0u128 into r92;
    or r91 r92 into r93;
    mul r72.size r90 into r94;
    div r94 1000000u128 into r95;
    ternary r93 0u128 r95 into r96;
    add r89 r96 into r97;
    get oracle_perps_v1.aleo/max_price[r1] into r98;
    pow 10u128 6u8 into r99;
    mul r97 r99 into r100;
    div r100 r98 into r101;
    get.or_use fee_reserves[r1] 0u128 into r102;
    add r102 r101 into r103;
    set r103 into fee_reserves[r1];
    ternary r5 r32 r31 into r104;
    contains min_profit_block[true] into r105;
    assert.eq r105 true;
    get min_profit_block[true] into r106;
    add r72.last_increased_block r106 into r107;
    gt block.height r107 into r108;
    get.or_use min_profit_basis_points[r2] 0u32 into r109;
    ternary r108 0u32 r109 into r110;
    gt r72.average_price r104 into r111;
    sub.w r72.average_price r104 into r112;
    sub.w r104 r72.average_price into r113;
    ternary r111 r112 r113 into r114;
    is.eq r72.average_price 0u128 into r115;
    ternary r115 1u128 r72.average_price into r116;
    is.eq r72.average_price 0u128 into r117;
    mul r72.size r114 into r118;
    div.w r118 r116 into r119;
    ternary r117 0u128 r119 into r120;
    gt r104 r72.average_price into r121;
    gt r72.average_price r104 into r122;
    ternary r5 r121 r122 into r123;
    mul r120 10000u128 into r124;
    cast r110 into r125 as u128;
    mul r72.size r125 into r126;
    lte r124 r126 into r127;
    and r123 r127 into r128;
    ternary r128 0u128 r120 into r129;
    mul r4 r129 into r130;
    div r130 r72.size into r131;
    ternary r123 r131 0u128 into r132;
    cast r131 into r133 as i128;
    add r72.realised_pnl r133 into r134;
    cast r131 into r135 as i128;
    sub.w r72.realised_pnl r135 into r136;
    ternary r123 r134 r136 into r137;
    sub.w r72.collateral r131 into r138;
    ternary r123 r72.collateral r138 into r139;
    add r132 r3 into r140;
    sub r139 r3 into r141;
    is.eq r72.size r4 into r142;
    add r140 r141 into r143;
    ternary r142 r143 r140 into r144;
    is.eq r72.size r4 into r145;
    ternary r145 0u128 r141 into r146;
    pow 10u128 6u8 into r147;
    mul r131 r147 into r148;
    div r148 r98 into r149;
    sub.w r46 r149 into r150;
    add r46 r149 into r151;
    ternary r123 r150 r151 into r152;
    ternary r5 r46 r152 into r153;
    set r153 into pool_amounts[r1];
    gt r144 r97 into r154;
    sub.w r144 r97 into r155;
    ternary r154 r155 r144 into r156;
    lte r144 r97 into r157;
    sub.w r146 r97 into r158;
    ternary r157 r158 r146 into r159;
    lte r144 r97 into r160;
    and r160 r5 into r161;
    ternary r161 r101 0u128 into r162;
    get pool_amounts[r1] into r163;
    sub r163 r162 into r164;
    set r164 into pool_amounts[r1];
    get.or_use reserve_amounts[r1] 0u128 into r165;
    get pool_amounts[r1] into r166;
    lte r165 r166 into r167;
    assert.eq r167 true;
    is.eq r72.size r4 into r168;
    sub r72.size r4 into r169;
    ternary r168 0u128 r169 into r170;
    is.eq r72.size r4 into r171;
    ternary r171 0u128 r83 into r172;
    is.eq r72.size r4 into r173;
    ternary r173 0u128 r72.average_price into r174;
    is.eq r72.size r4 into r175;
    ternary r175 0u32 r72.last_increased_block into r176;
    cast r170 r159 r174 r172 r80 r137 r176 into r177 as Position;
    set r177 into positions[r71];
    get positions[r71] into r178;
    gte r170 r159 into r179;
    assert.eq r179 true;
    gt r178.average_price r104 into r180;
    sub.w r178.average_price r104 into r181;
    sub.w r104 r178.average_price into r182;
    ternary r180 r181 r182 into r183;
    is.eq r178.average_price 0u128 into r184;
    ternary r184 1u128 r178.average_price into r185;
    is.eq r178.average_price 0u128 into r186;
    mul r178.size r183 into r187;
    div.w r187 r185 into r188;
    ternary r186 0u128 r188 into r189;
    gt r104 r178.average_price into r190;
    gt r178.average_price r104 into r191;
    ternary r5 r190 r191 into r192;
    mul r189 10000u128 into r193;
    cast r110 into r194 as u128;
    mul r178.size r194 into r195;
    lte r193 r195 into r196;
    and r192 r196 into r197;
    ternary r197 0u128 r189 into r198;
    is.eq r178.size 0u128 into r199;
    sub 10000u128 10u128 into r200;
    mul r178.size r200 into r201;
    div r201 10000u128 into r202;
    sub r178.size r202 into r203;
    ternary r199 0u128 r203 into r204;
    sub r83 r178.entry_funding_rate into r205;
    is.eq r178.size 0u128 into r206;
    is.eq r205 0u128 into r207;
    or r206 r207 into r208;
    mul r178.size r205 into r209;
    div r209 1000000u128 into r210;
    ternary r208 0u128 r210 into r211;
    add r204 r211 into r212;
    not r192 into r213;
    gte r159 r198 into r214;
    and r213 r214 into r215;
    sub.w r159 r198 into r216;
    ternary r215 r216 0u128 into r217;
    ternary r192 r159 r217 into r218;
    is.neq r218 0u128 into r219;
    lt r218 r212 into r220;
    and r219 r220 into r221;
    is.neq r218 0u128 into r222;
    gte r218 r212 into r223;
    and r222 r223 into r224;
    add r212 5000000u128 into r225;
    lt r218 r225 into r226;
    and r224 r226 into r227;
    is.neq r218 0u128 into r228;
    add r212 5000000u128 into r229;
    gte r218 r229 into r230;
    and r228 r230 into r231;
    mul r218 500000u128 into r232;
    mul r170 10000u128 into r233;
    lt r232 r233 into r234;
    and r231 r234 into r235;
    is.eq r218 0u128 into r236;
    or r236 r221 into r237;
    or r237 r227 into r238;
    ternary r235 2u8 0u8 into r239;
    ternary r238 1u8 r239 into r240;
    ternary r221 r218 r212 into r241;
    is.eq r72.size r4 into r242;
    ternary r242 0u8 r240 into r243;
    is.eq r243 0u8 into r244;
    assert.eq r244 true;
    get.or_use guaranteed_usd[r1] 0u128 into r245;
    is.neq r72.size r4 into r246;
    and r5 r246 into r247;
    add r245 r72.collateral into r248;
    sub.w r248 r178.collateral into r249;
    sub.w r249 r4 into r250;
    is.eq r72.size r4 into r251;
    and r5 r251 into r252;
    add r245 r72.collateral into r253;
    sub.w r253 r4 into r254;
    ternary r252 r254 r245 into r255;
    ternary r247 r250 r255 into r256;
    set r256 into guaranteed_usd[r1];
    get.or_use global_short_sizes[r2] 0u128 into r257;
    not r5 into r258;
    gt r4 r257 into r259;
    and r258 r259 into r260;
    not r5 into r261;
    lte r4 r257 into r262;
    and r261 r262 into r263;
    sub.w r257 r4 into r264;
    ternary r263 r264 r257 into r265;
    ternary r260 0u128 r265 into r266;
    set r266 into global_short_sizes[r2];
    get pool_amounts[r1] into r267;
    pow 10u128 6u8 into r268;
    mul r144 r268 into r269;
    div r269 r98 into r270;
    gt r144 0u128 into r271;
    and r271 r5 into r272;
    sub.w r267 r270 into r273;
    ternary r272 r273 r267 into r274;
    set r274 into pool_amounts[r1];
    pow 10u128 6u8 into r275;
    mul r156 r275 into r276;
    div r276 r98 into r277;
    cast r1 r6 into r278 as AccountKey;
    hash.bhp256 r278 into r279 as field;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r280 as AccountKey;
    hash.bhp256 r280 into r281 as field;
    get.or_use account[r279] 0u128 into r282;
    add r282 r277 into r283;
    set r283 into account[r279];
    get account[r281] into r284;
    sub r284 r277 into r285;
    set r285 into account[r281];


function liquidate_position:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as boolean.public;
    input r4 as address.public;
    async liquidate_position self.caller r0 r1 r2 r3 r4 into r5;
    output r5 as pool_perps_v1.aleo/liquidate_position.future;

finalize liquidate_position:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as field.public;
    input r3 as field.public;
    input r4 as boolean.public;
    input r5 as address.public;
    contains whitelist_token_ids[true] into r6;
    assert.eq r6 true;
    get whitelist_token_ids[true] into r7;
    is.eq r7[0u32] r2 into r8;
    is.eq r7[1u32] r2 into r9;
    or r8 r9 into r10;
    is.eq r7[2u32] r2 into r11;
    or r10 r11 into r12;
    is.eq r7[3u32] r2 into r13;
    or r12 r13 into r14;
    is.eq r7[4u32] r2 into r15;
    or r14 r15 into r16;
    assert.eq r16 true;
    get whitelist_token_ids[true] into r17;
    is.eq r17[0u32] r3 into r18;
    is.eq r17[1u32] r3 into r19;
    or r18 r19 into r20;
    is.eq r17[2u32] r3 into r21;
    or r20 r21 into r22;
    is.eq r17[3u32] r3 into r23;
    or r22 r23 into r24;
    is.eq r17[4u32] r3 into r25;
    or r24 r25 into r26;
    assert.eq r26 true;
    contains tokens[r2] into r27;
    assert.eq r27 true;
    contains tokens[r3] into r28;
    assert.eq r28 true;
    contains in_private_liquidation_mode[true] into r29;
    assert.eq r29 true;
    get in_private_liquidation_mode[true] into r30;
    get.or_use is_liquidator[r0] false into r31;
    ternary r30 r31 true into r32;
    assert.eq r32 true;
    get.or_use last_funding_blocks[r2] 0u32 into r33;
    div block.height 5760u32 into r34;
    mul r34 5760u32 into r35;
    is.eq r33 0u32 into r36;
    is.neq r33 0u32 into r37;
    add r33 5760u32 into r38;
    gt r38 block.height into r39;
    and r37 r39 into r40;
    ternary r40 r33 r35 into r41;
    ternary r36 r35 r41 into r42;
    get.or_use pool_amounts[r2] 0u128 into r43;
    sub block.height r33 into r44;
    div r44 5760u32 into r45;
    contains funding_rate_config[true] into r46;
    assert.eq r46 true;
    get funding_rate_config[true] into r47;
    get stable_tokens[r2] into r48;
    ternary r48 r47.stable_funding_rate_factor r47.funding_rate_factor into r49;
    is.eq r43 0u128 into r50;
    add r33 5760u32 into r51;
    gt r51 block.height into r52;
    or r50 r52 into r53;
    ternary r53 1u128 r43 into r54;
    is.eq r43 0u128 into r55;
    add r33 5760u32 into r56;
    gt r56 block.height into r57;
    or r55 r57 into r58;
    get.or_use reserve_amounts[r2] 0u128 into r59;
    mul r49 r59 into r60;
    cast r45 into r61 as u128;
    mul r60 r61 into r62;
    div.w r62 r54 into r63;
    ternary r58 0u128 r63 into r64;
    get.or_use cumulative_funding_rates[r2] 0u128 into r65;
    add r65 r64 into r66;
    set r66 into cumulative_funding_rates[r2];
    set r42 into last_funding_blocks[r2];
    cast r1 r2 r3 r4 into r67 as PositionKey;
    hash.bhp256 r67 into r68 as field;
    get positions[r68] into r69;
    gt r69.size 0u128 into r70;
    assert.eq r70 true;
    get oracle_perps_v1.aleo/max_price[r3] into r71;
    get oracle_perps_v1.aleo/min_price[r3] into r72;
    ternary r4 r72 r71 into r73;
    contains min_profit_block[true] into r74;
    assert.eq r74 true;
    get min_profit_block[true] into r75;
    add r69.last_increased_block r75 into r76;
    gt block.height r76 into r77;
    get.or_use min_profit_basis_points[r3] 0u32 into r78;
    ternary r77 0u32 r78 into r79;
    gt r69.average_price r73 into r80;
    sub.w r69.average_price r73 into r81;
    sub.w r73 r69.average_price into r82;
    ternary r80 r81 r82 into r83;
    is.eq r69.average_price 0u128 into r84;
    ternary r84 1u128 r69.average_price into r85;
    is.eq r69.average_price 0u128 into r86;
    mul r69.size r83 into r87;
    div.w r87 r85 into r88;
    ternary r86 0u128 r88 into r89;
    gt r73 r69.average_price into r90;
    gt r69.average_price r73 into r91;
    ternary r4 r90 r91 into r92;
    mul r89 10000u128 into r93;
    cast r79 into r94 as u128;
    mul r69.size r94 into r95;
    lte r93 r95 into r96;
    and r92 r96 into r97;
    ternary r97 0u128 r89 into r98;
    get cumulative_funding_rates[r2] into r99;
    is.eq r69.size 0u128 into r100;
    sub 10000u128 10u128 into r101;
    mul r69.size r101 into r102;
    div r102 10000u128 into r103;
    sub r69.size r103 into r104;
    ternary r100 0u128 r104 into r105;
    sub r99 r69.entry_funding_rate into r106;
    is.eq r69.size 0u128 into r107;
    is.eq r106 0u128 into r108;
    or r107 r108 into r109;
    mul r69.size r106 into r110;
    div r110 1000000u128 into r111;
    ternary r109 0u128 r111 into r112;
    add r105 r112 into r113;
    not r92 into r114;
    gte r69.collateral r98 into r115;
    and r114 r115 into r116;
    sub.w r69.collateral r98 into r117;
    ternary r116 r117 0u128 into r118;
    ternary r92 r69.collateral r118 into r119;
    is.neq r119 0u128 into r120;
    lt r119 r113 into r121;
    and r120 r121 into r122;
    is.neq r119 0u128 into r123;
    gte r119 r113 into r124;
    and r123 r124 into r125;
    add r113 5000000u128 into r126;
    lt r119 r126 into r127;
    and r125 r127 into r128;
    is.neq r119 0u128 into r129;
    add r113 5000000u128 into r130;
    gte r119 r130 into r131;
    and r129 r131 into r132;
    mul r119 500000u128 into r133;
    mul r69.size 10000u128 into r134;
    lt r133 r134 into r135;
    and r132 r135 into r136;
    is.eq r119 0u128 into r137;
    or r137 r122 into r138;
    or r138 r128 into r139;
    ternary r136 2u8 0u8 into r140;
    ternary r139 1u8 r140 into r141;
    ternary r122 r119 r113 into r142;
    is.neq r141 0u8 into r143;
    assert.eq r143 true;
    get oracle_perps_v1.aleo/max_price[r2] into r144;
    is.eq r141 2u8 into r145;
    and r145 r92 into r146;
    gt r98 0u128 into r147;
    and r146 r147 into r148;
    ternary r148 r98 0u128 into r149;
    is.eq r141 2u8 into r150;
    not r92 into r151;
    and r150 r151 into r152;
    gt r98 0u128 into r153;
    and r152 r153 into r154;
    sub.w r69.collateral r98 into r155;
    ternary r154 r155 r69.collateral into r156;
    is.eq r141 2u8 into r157;
    add r149 r156 into r158;
    ternary r157 r158 0u128 into r159;
    is.eq r141 2u8 into r160;
    sub.w r159 r113 into r161;
    ternary r160 r161 0u128 into r162;
    is.eq r141 2u8 into r163;
    pow 10u128 6u8 into r164;
    mul r162 r164 into r165;
    div r165 r144 into r166;
    ternary r163 r166 0u128 into r167;
    get pool_amounts[r2] into r168;
    is.eq r141 2u8 into r169;
    and r169 r92 into r170;
    gt r98 0u128 into r171;
    and r170 r171 into r172;
    not r4 into r173;
    and r172 r173 into r174;
    is.eq r141 2u8 into r175;
    not r92 into r176;
    and r175 r176 into r177;
    gt r98 0u128 into r178;
    and r177 r178 into r179;
    not r4 into r180;
    and r179 r180 into r181;
    pow 10u128 6u8 into r182;
    mul r98 r182 into r183;
    div r183 r144 into r184;
    sub.w r168 r184 into r185;
    add r168 r184 into r186;
    ternary r181 r186 r168 into r187;
    ternary r174 r185 r187 into r188;
    set r188 into pool_amounts[r2];
    is.eq r141 2u8 into r189;
    gt r159 0u128 into r190;
    and r189 r190 into r191;
    and r191 r4 into r192;
    pow 10u128 6u8 into r193;
    mul r159 r193 into r194;
    div r194 r144 into r195;
    ternary r192 r195 0u128 into r196;
    get pool_amounts[r2] into r197;
    sub r197 r196 into r198;
    set r198 into pool_amounts[r2];
    cast r2 r1 into r199 as AccountKey;
    hash.bhp256 r199 into r200 as field;
    get account[r200] into r201;
    add r201 r167 into r202;
    set r202 into account[r200];
    cast r2 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r203 as AccountKey;
    hash.bhp256 r203 into r204 as field;
    get account[r204] into r205;
    sub r205 r167 into r206;
    set r206 into account[r204];
    pow 10u128 6u8 into r207;
    mul r113 r207 into r208;
    div r208 r144 into r209;
    pow 10u128 6u8 into r210;
    mul r142 r210 into r211;
    div r211 r144 into r212;
    is.eq r141 2u8 into r213;
    ternary r213 r209 r212 into r214;
    get.or_use fee_reserves[r2] 0u128 into r215;
    add r215 r214 into r216;
    set r216 into fee_reserves[r2];
    is.eq r141 1u8 into r217;
    and r217 r4 into r218;
    ternary r218 r212 0u128 into r219;
    get pool_amounts[r2] into r220;
    sub r220 r219 into r221;
    set r221 into pool_amounts[r2];
    is.eq r141 1u8 into r222;
    not r4 into r223;
    and r222 r223 into r224;
    lt r142 r69.collateral into r225;
    and r224 r225 into r226;
    sub.w r69.collateral r142 into r227;
    pow 10u128 6u8 into r228;
    mul r227 r228 into r229;
    div r229 r144 into r230;
    ternary r226 r230 0u128 into r231;
    get pool_amounts[r2] into r232;
    add r232 r231 into r233;
    set r233 into pool_amounts[r2];
    is.eq r141 1u8 into r234;
    pow 10u128 6u8 into r235;
    mul 5000000u128 r235 into r236;
    div r236 r144 into r237;
    ternary r234 r237 0u128 into r238;
    get pool_amounts[r2] into r239;
    sub r239 r238 into r240;
    set r240 into pool_amounts[r2];
    cast r2 r5 into r241 as AccountKey;
    hash.bhp256 r241 into r242 as field;
    get.or_use account[r242] 0u128 into r243;
    add r243 r238 into r244;
    set r244 into account[r242];
    get account[r204] into r245;
    sub r245 r238 into r246;
    set r246 into account[r204];
    get reserve_amounts[r2] into r247;
    sub r247 r69.reserve_amount into r248;
    set r248 into reserve_amounts[r2];
    get.or_use guaranteed_usd[r2] 0u128 into r249;
    add r249 r69.collateral into r250;
    sub.w r250 r69.size into r251;
    ternary r4 r251 r249 into r252;
    set r252 into guaranteed_usd[r2];
    get.or_use global_short_sizes[r3] 0u128 into r253;
    not r4 into r254;
    gt r253 r69.size into r255;
    and r254 r255 into r256;
    sub.w r253 r69.size into r257;
    not r4 into r258;
    lte r253 r69.size into r259;
    and r258 r259 into r260;
    ternary r260 0u128 r253 into r261;
    ternary r256 r257 r261 into r262;
    set r262 into global_short_sizes[r3];
    remove positions[r68];


function swap:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0 r2 into r5;
    assert.eq r5 true;
    is.neq r0 5831693778411205416925069027464809696308596398099265250571387651489705378046field into r6;
    assert.eq r6 true;
    is.neq r2 5831693778411205416925069027464809696308596398099265250571387651489705378046field into r7;
    assert.eq r7 true;
    is.neq r0 6769995254802454894577392401849975163810476770055238272962759031196088045850field into r8;
    assert.eq r8 true;
    is.neq r2 6769995254802454894577392401849975163810476770055238272962759031196088045850field into r9;
    assert.eq r9 true;
    gt r1 0u128 into r10;
    assert.eq r10 true;
    async swap self.caller r0 r1 r2 r3 r4 into r11;
    output r11 as pool_perps_v1.aleo/swap.future;

finalize swap:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as field.public;
    input r4 as u128.public;
    input r5 as address.public;
    contains tokens[r1] into r6;
    assert.eq r6 true;
    contains tokens[r3] into r7;
    assert.eq r7 true;
    contains is_swap_enabled[true] into r8;
    assert.eq r8 true;
    get is_swap_enabled[true] into r9;
    assert.eq r9 true;
    contains whitelist_token_ids[true] into r10;
    assert.eq r10 true;
    get whitelist_token_ids[true] into r11;
    is.eq r11[0u32] r1 into r12;
    is.eq r11[1u32] r1 into r13;
    or r12 r13 into r14;
    is.eq r11[2u32] r1 into r15;
    or r14 r15 into r16;
    is.eq r11[3u32] r1 into r17;
    or r16 r17 into r18;
    is.eq r11[4u32] r1 into r19;
    or r18 r19 into r20;
    assert.eq r20 true;
    get whitelist_token_ids[true] into r21;
    is.eq r21[0u32] r3 into r22;
    is.eq r21[1u32] r3 into r23;
    or r22 r23 into r24;
    is.eq r21[2u32] r3 into r25;
    or r24 r25 into r26;
    is.eq r21[3u32] r3 into r27;
    or r26 r27 into r28;
    is.eq r21[4u32] r3 into r29;
    or r28 r29 into r30;
    assert.eq r30 true;
    cast r1 r0 into r31 as AccountKey;
    hash.bhp256 r31 into r32 as field;
    cast r1 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r33 as AccountKey;
    hash.bhp256 r33 into r34 as field;
    get account[r32] into r35;
    gte r35 r2 into r36;
    assert.eq r36 true;
    sub r35 r2 into r37;
    set r37 into account[r32];
    get.or_use account[r34] 0u128 into r38;
    add r38 r2 into r39;
    set r39 into account[r34];
    get.or_use last_funding_blocks[r1] 0u32 into r40;
    div block.height 5760u32 into r41;
    mul r41 5760u32 into r42;
    is.eq r40 0u32 into r43;
    is.neq r40 0u32 into r44;
    add r40 5760u32 into r45;
    gt r45 block.height into r46;
    and r44 r46 into r47;
    ternary r47 r40 r42 into r48;
    ternary r43 r42 r48 into r49;
    get.or_use pool_amounts[r1] 0u128 into r50;
    sub block.height r40 into r51;
    div r51 5760u32 into r52;
    contains funding_rate_config[true] into r53;
    assert.eq r53 true;
    get funding_rate_config[true] into r54;
    get stable_tokens[r1] into r55;
    ternary r55 r54.stable_funding_rate_factor r54.funding_rate_factor into r56;
    is.eq r50 0u128 into r57;
    add r40 5760u32 into r58;
    gt r58 block.height into r59;
    or r57 r59 into r60;
    ternary r60 1u128 r50 into r61;
    is.eq r50 0u128 into r62;
    add r40 5760u32 into r63;
    gt r63 block.height into r64;
    or r62 r64 into r65;
    get.or_use reserve_amounts[r1] 0u128 into r66;
    mul r56 r66 into r67;
    cast r52 into r68 as u128;
    mul r67 r68 into r69;
    div.w r69 r61 into r70;
    ternary r65 0u128 r70 into r71;
    get.or_use cumulative_funding_rates[r1] 0u128 into r72;
    add r72 r71 into r73;
    set r73 into cumulative_funding_rates[r1];
    set r49 into last_funding_blocks[r1];
    get.or_use last_funding_blocks[r3] 0u32 into r74;
    is.eq r74 0u32 into r75;
    is.neq r74 0u32 into r76;
    add r74 5760u32 into r77;
    gt r77 block.height into r78;
    and r76 r78 into r79;
    ternary r79 r74 r42 into r80;
    ternary r75 r42 r80 into r81;
    get.or_use pool_amounts[r3] 0u128 into r82;
    sub block.height r74 into r83;
    div r83 5760u32 into r84;
    get stable_tokens[r3] into r85;
    ternary r85 r54.stable_funding_rate_factor r54.funding_rate_factor into r86;
    is.eq r82 0u128 into r87;
    add r74 5760u32 into r88;
    gt r88 block.height into r89;
    or r87 r89 into r90;
    ternary r90 1u128 r82 into r91;
    is.eq r82 0u128 into r92;
    add r74 5760u32 into r93;
    gt r93 block.height into r94;
    or r92 r94 into r95;
    get.or_use reserve_amounts[r3] 0u128 into r96;
    mul r86 r96 into r97;
    cast r84 into r98 as u128;
    mul r97 r98 into r99;
    div r99 r91 into r100;
    ternary r95 0u128 r100 into r101;
    get.or_use cumulative_funding_rates[r3] 0u128 into r102;
    add r102 r101 into r103;
    set r103 into cumulative_funding_rates[r3];
    set r81 into last_funding_blocks[r3];
    get oracle_perps_v1.aleo/min_price[r1] into r104;
    get oracle_perps_v1.aleo/max_price[r3] into r105;
    mul r2 r104 into r106;
    div r106 r105 into r107;
    mul r2 r104 into r108;
    pow 10u128 6u8 into r109;
    div r108 r109 into r110;
    get stable_tokens[r1] into r111;
    get stable_tokens[r3] into r112;
    and r111 r112 into r113;
    ternary r113 4u128 30u128 into r114;
    ternary r113 20u128 50u128 into r115;
    get tokens[5831693778411205416925069027464809696308596398099265250571387651489705378046field] into r116;
    get.or_use usda_amounts[r1] 0u128 into r117;
    contains total_token_weights[true] into r118;
    assert.eq r118 true;
    get total_token_weights[true] into r119;
    is.eq r119 0u128 into r120;
    ternary r120 1u128 r119 into r121;
    get.or_use token_weights[r1] 0u128 into r122;
    mul r122 r116.total_supply into r123;
    div r123 r121 into r124;
    add r117 r110 into r125;
    gt r110 r117 into r126;
    sub.w r117 r110 into r127;
    ternary r126 0u128 r127 into r128;
    ternary true r125 r128 into r129;
    gt r117 r124 into r130;
    sub.w r117 r124 into r131;
    sub.w r124 r117 into r132;
    ternary r130 r131 r132 into r133;
    gt r129 r124 into r134;
    sub.w r129 r124 into r135;
    sub.w r124 r129 into r136;
    ternary r134 r135 r136 into r137;
    is.neq r124 0u128 into r138;
    lt r137 r133 into r139;
    and r138 r139 into r140;
    ternary r140 r124 1u128 into r141;
    lt r137 r133 into r142;
    is.neq r124 0u128 into r143;
    and r142 r143 into r144;
    mul r115 r133 into r145;
    div r145 r141 into r146;
    ternary r144 r146 0u128 into r147;
    lt r137 r133 into r148;
    lte r147 r114 into r149;
    and r148 r149 into r150;
    sub.w r114 r147 into r151;
    ternary r150 r151 0u128 into r152;
    gt r137 r133 into r153;
    add r133 r137 into r154;
    div r154 2u128 into r155;
    ternary r153 r155 0u128 into r156;
    gt r156 r124 into r157;
    ternary r157 r124 r156 into r158;
    is.eq r124 0u128 into r159;
    ternary r159 2u128 r124 into r160;
    not false into r161;
    is.eq r124 0u128 into r162;
    or r161 r162 into r163;
    lt r137 r133 into r164;
    mul r115 r158 into r165;
    div r165 r160 into r166;
    add r114 r166 into r167;
    ternary r164 r152 r167 into r168;
    ternary r163 r114 r168 into r169;
    get.or_use usda_amounts[r3] 0u128 into r170;
    get.or_use token_weights[r3] 0u128 into r171;
    mul r171 r116.total_supply into r172;
    div r172 r121 into r173;
    add r170 r110 into r174;
    gt r110 r170 into r175;
    sub.w r170 r110 into r176;
    ternary r175 0u128 r176 into r177;
    ternary false r174 r177 into r178;
    gt r170 r173 into r179;
    sub.w r170 r173 into r180;
    sub.w r173 r170 into r181;
    ternary r179 r180 r181 into r182;
    gt r178 r173 into r183;
    sub.w r178 r173 into r184;
    sub.w r173 r178 into r185;
    ternary r183 r184 r185 into r186;
    is.neq r173 0u128 into r187;
    lt r186 r182 into r188;
    and r187 r188 into r189;
    ternary r189 r173 1u128 into r190;
    lt r186 r182 into r191;
    is.neq r173 0u128 into r192;
    and r191 r192 into r193;
    mul r115 r182 into r194;
    div r194 r190 into r195;
    ternary r193 r195 0u128 into r196;
    lt r186 r182 into r197;
    lte r196 r114 into r198;
    and r197 r198 into r199;
    sub.w r114 r196 into r200;
    ternary r199 r200 0u128 into r201;
    gt r186 r182 into r202;
    add r182 r186 into r203;
    div r203 2u128 into r204;
    ternary r202 r204 0u128 into r205;
    gt r205 r173 into r206;
    ternary r206 r173 r205 into r207;
    is.eq r173 0u128 into r208;
    ternary r208 2u128 r173 into r209;
    not false into r210;
    is.eq r173 0u128 into r211;
    or r210 r211 into r212;
    lt r186 r182 into r213;
    mul r115 r207 into r214;
    div r214 r209 into r215;
    add r114 r215 into r216;
    ternary r213 r201 r216 into r217;
    ternary r212 r114 r217 into r218;
    gt r169 r218 into r219;
    ternary r219 r169 r218 into r220;
    sub 10000u128 r220 into r221;
    mul r107 r221 into r222;
    div r222 10000u128 into r223;
    sub r107 r223 into r224;
    get.or_use fee_reserves[r3] 0u128 into r225;
    add r225 r224 into r226;
    set r226 into fee_reserves[r3];
    get.or_use usda_amounts[r1] 0u128 into r227;
    add r227 r110 into r228;
    set r228 into usda_amounts[r1];
    get.or_use max_usda_amounts[r1] 0u128 into r229;
    gt r229 0u128 into r230;
    get usda_amounts[r1] into r231;
    lte r231 r229 into r232;
    ternary r230 r232 true into r233;
    assert.eq r233 true;
    get.or_use usda_amounts[r3] 0u128 into r234;
    lte r234 r110 into r235;
    sub.w r234 r110 into r236;
    ternary r235 0u128 r236 into r237;
    set r237 into usda_amounts[r3];
    get.or_use pool_amounts[r1] 0u128 into r238;
    add r238 r2 into r239;
    set r239 into pool_amounts[r1];
    get pool_amounts[r1] into r240;
    get account[r34] into r241;
    lte r240 r241 into r242;
    assert.eq r242 true;
    get pool_amounts[r3] into r243;
    sub r243 r107 into r244;
    set r244 into pool_amounts[r3];
    get.or_use reserve_amounts[r3] 0u128 into r245;
    get pool_amounts[r3] into r246;
    lte r245 r246 into r247;
    assert.eq r247 true;
    gte r223 r4 into r248;
    assert.eq r248 true;
    cast r3 r5 into r249 as AccountKey;
    hash.bhp256 r249 into r250 as field;
    cast r3 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r251 as AccountKey;
    hash.bhp256 r251 into r252 as field;
    get.or_use account[r250] 0u128 into r253;
    add r253 r223 into r254;
    set r254 into account[r250];
    get account[r252] into r255;
    sub r255 r223 into r256;
    set r256 into account[r252];


function init_super_admin:
    input r0 as address.public;
    assert.eq self.caller aleo1cnm2w8qlrhahlsmalph7t0jh3adny5pj4m38jgpcdzt2reqthurqaen3dp;
    async init_super_admin r0 into r1;
    output r1 as pool_perps_v1.aleo/init_super_admin.future;

finalize init_super_admin:
    input r0 as address.public;
    contains super_admin[true] into r1;
    not r1 into r2;
    assert.eq r2 true;
    set r0 into super_admin[true];


function change_admin:
    input r0 as address.public;
    async change_admin self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/change_admin.future;

finalize change_admin:
    input r0 as address.public;
    input r1 as address.public;
    contains super_admin[true] into r2;
    assert.eq r2 true;
    get super_admin[true] into r3;
    assert.eq r0 r3;
    set r1 into super_admin[true];


function set_governor:
    input r0 as address.public;
    input r1 as boolean.public;
    async set_governor self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_governor.future;

finalize set_governor:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as boolean.public;
    contains super_admin[true] into r3;
    assert.eq r3 true;
    get super_admin[true] into r4;
    assert.eq r0 r4;
    set r2 into is_governor[r1];


function withdraw_fee:
    input r0 as field.public;
    input r1 as address.public;
    cast r0 r1 into r2 as AccountKey;
    hash.bhp256 r2 into r3 as field;
    cast r0 aleo10x6sqsc8d353upatyuelqa4864leds5kuk3xqmgj7gxzfhux6vxsrne96y into r4 as AccountKey;
    hash.bhp256 r4 into r5 as field;
    async withdraw_fee self.caller r0 r3 r5 into r6;
    output r6 as pool_perps_v1.aleo/withdraw_fee.future;

finalize withdraw_fee:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as field.public;
    contains super_admin[true] into r4;
    assert.eq r4 true;
    get super_admin[true] into r5;
    assert.eq r0 r5;
    get.or_use fee_reserves[r1] 0u128 into r6;
    gt r6 0u128 into r7;
    assert.eq r7 true;
    set 0u128 into fee_reserves[r1];
    get.or_use account[r2] 0u128 into r8;
    add r8 r6 into r9;
    set r9 into account[r2];
    get account[r3] into r10;
    sub r10 r6 into r11;
    set r11 into account[r3];


function init_whitelist_token_ids:
    input r0 as [field; 5u32].public;
    async init_whitelist_token_ids self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/init_whitelist_token_ids.future;

finalize init_whitelist_token_ids:
    input r0 as address.public;
    input r1 as [field; 5u32].public;
    contains whitelist_token_ids[true] into r2;
    not r2 into r3;
    assert.eq r3 true;
    get.or_use is_governor[r0] false into r4;
    assert.eq r4 true;
    set r1 into whitelist_token_ids[true];


function set_cooldown_duration:
    input r0 as u32.public;
    async set_cooldown_duration self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_cooldown_duration.future;

finalize set_cooldown_duration:
    input r0 as address.public;
    input r1 as u32.public;
    get.or_use is_governor[r0] false into r2;
    assert.eq r2 true;
    lte r1 34560u32 into r3;
    assert.eq r3 true;
    set r1 into cooldown_duration[true];


function set_aum_config:
    input r0 as u128.public;
    input r1 as u128.public;
    async set_aum_config self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_aum_config.future;

finalize set_aum_config:
    input r0 as address.public;
    input r1 as u128.public;
    input r2 as u128.public;
    get.or_use is_governor[r0] false into r3;
    assert.eq r3 true;
    cast r1 r2 into r4 as AumConfig;
    set r4 into aum_config[true];


function set_funding_rate_config:
    input r0 as u128.public;
    input r1 as u128.public;
    async set_funding_rate_config self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_funding_rate_config.future;

finalize set_funding_rate_config:
    input r0 as address.public;
    input r1 as u128.public;
    input r2 as u128.public;
    get is_governor[r0] into r3;
    assert.eq r3 true;
    cast r1 r2 into r4 as FundingRateConfig;
    set r4 into funding_rate_config[true];


function set_token_config:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as u128.public;
    input r3 as u32.public;
    input r4 as boolean.public;
    async set_token_config self.caller r0 r1 r2 r3 r4 into r5;
    output r5 as pool_perps_v1.aleo/set_token_config.future;

finalize set_token_config:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u32.public;
    input r5 as boolean.public;
    get is_governor[r0] into r6;
    assert.eq r6 true;
    contains whitelist_token_ids[true] into r7;
    assert.eq r7 true;
    get whitelist_token_ids[true] into r8;
    is.eq r8[0u32] r1 into r9;
    is.eq r8[1u32] r1 into r10;
    or r9 r10 into r11;
    is.eq r8[2u32] r1 into r12;
    or r11 r12 into r13;
    is.eq r8[3u32] r1 into r14;
    or r13 r14 into r15;
    is.eq r8[4u32] r1 into r16;
    or r15 r16 into r17;
    assert.eq r17 true;
    get.or_use total_token_weights[true] 0u128 into r18;
    add r18 r2 into r19;
    get.or_use token_weights[r1] 0u128 into r20;
    sub r19 r20 into r21;
    set r21 into total_token_weights[true];
    set r5 into stable_tokens[r1];
    set r2 into token_weights[r1];
    set r3 into max_usda_amounts[r1];
    set r4 into min_profit_basis_points[r1];


function set_usda_amount:
    input r0 as field.public;
    input r1 as u128.public;
    async set_usda_amount self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_usda_amount.future;

finalize set_usda_amount:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    get is_governor[r0] into r3;
    assert.eq r3 true;
    get usda_amounts[r1] into r4;
    gt r2 r4 into r5;
    set r2 into usda_amounts[r1];
    get.or_use max_usda_amounts[r1] 0u128 into r6;
    is.neq r6 0u128 into r7;
    and r5 r7 into r8;
    branch.eq r8 false to end_then_0_0;
    lte r2 r6 into r9;
    assert.eq r9 true;
    position end_then_0_0;


function set_min_profit_block:
    input r0 as u32.public;
    async set_min_profit_block self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_min_profit_block.future;

finalize set_min_profit_block:
    input r0 as address.public;
    input r1 as u32.public;
    get is_governor[r0] into r2;
    assert.eq r2 true;
    set r1 into min_profit_block[true];


function set_in_private_liquidation_mode:
    input r0 as boolean.public;
    async set_in_private_liquidation_mode self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_in_private_liquidation_mode.future;

finalize set_in_private_liquidation_mode:
    input r0 as address.public;
    input r1 as boolean.public;
    get is_governor[r0] into r2;
    assert.eq r2 true;
    set r1 into in_private_liquidation_mode[true];


function set_liquidator:
    input r0 as address.public;
    input r1 as boolean.public;
    async set_liquidator self.caller r0 r1 into r2;
    output r2 as pool_perps_v1.aleo/set_liquidator.future;

finalize set_liquidator:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as boolean.public;
    get is_governor[r0] into r3;
    assert.eq r3 true;
    set r2 into is_liquidator[r1];


function set_is_swap_enabled:
    input r0 as boolean.public;
    async set_is_swap_enabled self.caller r0 into r1;
    output r1 as pool_perps_v1.aleo/set_is_swap_enabled.future;

finalize set_is_swap_enabled:
    input r0 as address.public;
    input r1 as boolean.public;
    get is_governor[r0] into r2;
    assert.eq r2 true;
    set r1 into is_swap_enabled[true];
